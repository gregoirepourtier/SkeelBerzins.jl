<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solvers · SkeelBerzins.jl</title><meta name="title" content="Solvers · SkeelBerzins.jl"/><meta property="og:title" content="Solvers · SkeelBerzins.jl"/><meta property="twitter:title" content="Solvers · SkeelBerzins.jl"/><meta name="description" content="Documentation for SkeelBerzins.jl."/><meta property="og:description" content="Documentation for SkeelBerzins.jl."/><meta property="twitter:description" content="Documentation for SkeelBerzins.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SkeelBerzins.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../problem_definition/">Problem Definition</a></li><li class="is-active"><a class="tocitem" href>Solvers</a><ul class="internal"><li><a class="tocitem" href="#PDE-formulation"><span>PDE formulation</span></a></li><li><a class="tocitem" href="#Define-the-initial-conditions"><span>Define the initial conditions</span></a></li><li><a class="tocitem" href="#Define-the-boundary-conditions"><span>Define the boundary conditions</span></a></li><li><a class="tocitem" href="#Obtaining-Solutions"><span>Obtaining Solutions</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li></ul></li><li><a class="tocitem" href="../performance/">Achieve performance</a></li><li><a class="tocitem" href="../public_private_APIs/">Public and Private APIs</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../example101/">101: Linear Diffusion equation</a></li><li><a class="tocitem" href="../example102/">102: Nonlinear Diffusion equation</a></li><li><a class="tocitem" href="../example103/">103: Linear Diffusion equation in cylindrical coordinates</a></li><li><a class="tocitem" href="../example104/">104: Poisson equation</a></li><li><a class="tocitem" href="../example105/">105: Stationary nonlinear diffusion equation</a></li><li><a class="tocitem" href="../example106/">106: System of Reaction-Diffusion equations</a></li><li><a class="tocitem" href="../example107/">107: Linear Diffusion equation in spherical coordinates</a></li><li><a class="tocitem" href="../example201/">201: Interpolation of Partial Derivatives</a></li><li><a class="tocitem" href="../example301/">301: PDE Constrained Optimization</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gregoirepourtier/SkeelBerzins.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gregoirepourtier/SkeelBerzins.jl/blob/main/docs/src/solvers.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Solvers"><a class="docs-heading-anchor" href="#Solvers">Solvers</a><a id="Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers" title="Permalink"></a></h1><p>Now that we have an understanding of the overall problem definition, we can explore the various  solvers that are included in the package and investigate their specific input and output parameters  in detail.</p><p>The solvers expect the PDE problem to be described in the following way.</p><h2 id="PDE-formulation"><a class="docs-heading-anchor" href="#PDE-formulation">PDE formulation</a><a id="PDE-formulation-1"></a><a class="docs-heading-anchor-permalink" href="#PDE-formulation" title="Permalink"></a></h2><p>In order to define the PDE(s), we have to follow the format introduced in the previous section on  <a href="../problem_definition/#problem-definition">Problem definition</a>. For the purpose of this explanation, we use the function <code>pdefunction(x,t,u,dudx)</code> to describe the  PDE(s). The inputs of the function are self-explanatory. It will then return the capacity  <code>c(x,t,u,dudx)</code>, the flux <code>f(x,t,u,dudx)</code> and the source <code>s(x,t,u,dux)</code> terms.</p><p>This function will be passed as an argument to the solver.</p><h2 id="Define-the-initial-conditions"><a class="docs-heading-anchor" href="#Define-the-initial-conditions">Define the initial conditions</a><a id="Define-the-initial-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Define-the-initial-conditions" title="Permalink"></a></h2><p>To define the initial condition(s), we introduce the function <code>icfunction(x)</code> (once again, arbitrary  name). For problems that contain at least one parabolic equation, it will return the evaluation of  the initial condition on the spatial mesh <code>xmesh</code> at the initial time <span>$t_0$</span>.<br/>For stationary problems it will return the evaluation of the initial value on the spatial mesh  <code>xmesh</code> used for the newton solver.</p><p>This function will be passed as an argument to the solver.</p><h2 id="Define-the-boundary-conditions"><a class="docs-heading-anchor" href="#Define-the-boundary-conditions">Define the boundary conditions</a><a id="Define-the-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Define-the-boundary-conditions" title="Permalink"></a></h2><p>To represent the boundary condition, we introduce the function <code>bdfunction(xl,ul,xr,ur,t)</code>. The  input arguments are:</p><ul><li><code>xl</code>: left boundary point of the problem.</li><li><code>ul</code>: estimate of the solution evaluated at the left boundary of the domain.</li><li><code>xr</code>: right boundary point of the problem.</li><li><code>ur</code>: estimate of the solution evaluated at the right boundary of the domain.</li><li><code>t</code>: evaluates the boundary conditions at time <span>$t \in [t_0,t_{end}]$</span>.</li></ul><p>The function will return the boundary condition terms introduced in the problem definition section,  i.e. <code>p(x,t,u)</code> and <code>q(x,t)</code> for the left and right part of the spatial mesh.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If <span>$m&gt;0$</span> and the left boundary point of the domain is <span>$a=0$</span>, then the solver ignores the  given boundary condition to enforce the symmetry condition ensuring second-order accuracy in  space near x=0.</p></div></div><p>This function will be passed as an argument to the solver.</p><h2 id="Obtaining-Solutions"><a class="docs-heading-anchor" href="#Obtaining-Solutions">Obtaining Solutions</a><a id="Obtaining-Solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Obtaining-Solutions" title="Permalink"></a></h2><p>With the complete PDE formulation defined, we can now introduce the solver function <code>pdepe</code>.  Look <a href="../public_private_APIs/#SkeelBerzins.pdepe"><code>pdepe</code></a>.</p><h3 id="Solve-with-internal-method:-implicit-Euler-method"><a class="docs-heading-anchor" href="#Solve-with-internal-method:-implicit-Euler-method">Solve with internal method: implicit Euler method</a><a id="Solve-with-internal-method:-implicit-Euler-method-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-with-internal-method:-implicit-Euler-method" title="Permalink"></a></h3><h4 id="Parabolic-equation(s)"><a class="docs-heading-anchor" href="#Parabolic-equation(s)">Parabolic equation(s)</a><a id="Parabolic-equation(s)-1"></a><a class="docs-heading-anchor-permalink" href="#Parabolic-equation(s)" title="Permalink"></a></h4><p>The package contains an implementation of the implicit Euler method which can be used to solve  parabolic equation(s). The method has a first order error with respect to time.</p><h4 id="Elliptic-Equation(s)"><a class="docs-heading-anchor" href="#Elliptic-Equation(s)">Elliptic Equation(s)</a><a id="Elliptic-Equation(s)-1"></a><a class="docs-heading-anchor-permalink" href="#Elliptic-Equation(s)" title="Permalink"></a></h4><p>Only the internal method (implicit Euler method) can be used to solve stationary problems and is  written as follows:</p><p class="math-container">\[M \frac{u^{k+1}-u^k}{\Delta t} = A(u^{k+1})\]</p><p>with <span>$M$</span> the mass matrix, <span>$\Delta t$</span> the time step used for the time discretization, <span>$A$</span> the  (non)linear operator resulting from the space discretization, <span>$u^k$</span> and <span>$u^{k+1}$</span> the estimate  solutions at time <span>$t_0 + k \Delta t$</span> and <span>$t_0 + (k+1) \Delta t$</span> respectively.</p><p>In Julia, positive infinity is defined as <code>Inf</code>. By setting <span>$\Delta t =$</span> Inf, it follows that  <span>$\frac{1}{\Delta t} = 0$</span> and thus we are left with the stationary problem which can solved by  using the Newton solver (see <a href="../public_private_APIs/#SkeelBerzins.newton"><code>SkeelBerzins.newton</code></a>).</p><p>It results that the solution for the stationary problem can be obtained by running one iteration of  the implicit Euler method.</p><h3 id="Solve-with-DifferentialEquations.jl"><a class="docs-heading-anchor" href="#Solve-with-DifferentialEquations.jl">Solve with DifferentialEquations.jl</a><a id="Solve-with-DifferentialEquations.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-with-DifferentialEquations.jl" title="Permalink"></a></h3><p><a href="https://github.com/gregoirepourtier/SkeelBerzins.jl">SkeelBerzins.jl</a> is also compatible with the  <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a> package.</p><p>It is possible to return the data from the problem in a <a href="../public_private_APIs/#SkeelBerzins.ProblemDefinition"><code>SkeelBerzins.ProblemDefinition</code></a>  structure, then to define an ODEProblem and solve it using an ODE/DAE solver from  DifferentialEquations.jl.</p><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><h3 id="Solve-with-internal-method:-implicit-Euler-method-2"><a class="docs-heading-anchor" href="#Solve-with-internal-method:-implicit-Euler-method-2">Solve with internal method: implicit Euler method</a><a class="docs-heading-anchor-permalink" href="#Solve-with-internal-method:-implicit-Euler-method-2" title="Permalink"></a></h3><pre><code class="nohighlight hljs"># Example of solving a linear diffusion PDE using the internal implicit Euler method.

using SkeelBerzins

# Define symmetry of the problem
m = 0

# Define PDE Formulation
function pdefunction(x,t,u,dudx)
    c = 1
    f = dudx
    s = 0

    c,f,s
end

# Define the initial condition
icfunction(x) = exp(-100*(x-0.25)^2)

# Define the boundary condtions
function bdfunction(xl,ul,xr,ur,t)
    pl = 0
    ql = 1
    pr = 0
    qr = 1

    pl,ql,pr,qr
end

# Define the spatial discretization
xmesh = collect(range(0,1,length=21))

# Define the time interval
tspan = (0,1)

# Solve
sol = pdepe(m,pdefunction,icfunction,bdfunction,xmesh,tspan)</code></pre><h3 id="Solve-with-DifferentialEquations.jl-2"><a class="docs-heading-anchor" href="#Solve-with-DifferentialEquations.jl-2">Solve with DifferentialEquations.jl</a><a class="docs-heading-anchor-permalink" href="#Solve-with-DifferentialEquations.jl-2" title="Permalink"></a></h3><pre><code class="nohighlight hljs"># Example of solving a linear diffusion PDE using the DifferentialEquations.jl package.

using SkeelBerzins, DifferentialEquations

# Define symmetry of the problem
m = 0

# Define PDE Formulation
function pdefunction(x,t,u,dudx)
    c = 1
    f = dudx
    s = 0

    c,f,s
end

# Define the initial condition
icfunction(x) = exp(-100*(x-0.25)^2)

# Define the boundary condtions
function bdfunction(xl,ul,xr,ur,t)
    pl = 0
    ql = 1
    pr = 0
    qr = 1

    pl,ql,pr,qr
end

# Define the spatial discretization
xmesh = collect(range(0,1,length=21))

# Define the time interval
tspan = (0,1)

# Define Keyword Arguments
params = SkeelBerzins.Params()
params.solver = :DiffEq

# Solve
problem_data = pdepe(m,pdefunction,icfunction,bdfunction,xmesh,tspan ; params=params)
problem_ode = DifferentialEquations.ODEProblem(problem_data)
sol_ode = DifferentialEquations.solve(problem,Rosenbrock23())
sol = reshape(sol_ode,problem_data)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../problem_definition/">« Problem Definition</a><a class="docs-footer-nextpage" href="../performance/">Achieve performance »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Wednesday 25 October 2023 22:10">Wednesday 25 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
