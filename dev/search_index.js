var documenterSearchIndex = {"docs":
[{"location":"example103/#Example-103:-Nonlinear-Diffusion-equation-(DiffEq)","page":"103: Nonlinear Diffusion equation (DiffEq)","title":"Example 103: Nonlinear Diffusion equation (DiffEq)","text":"","category":"section"},{"location":"example103/","page":"103: Nonlinear Diffusion equation (DiffEq)","title":"103: Nonlinear Diffusion equation (DiffEq)","text":"Solve the following nonlinear diffusion equation:","category":"page"},{"location":"example103/","page":"103: Nonlinear Diffusion equation (DiffEq)","title":"103: Nonlinear Diffusion equation (DiffEq)","text":"u_t  = (2uu_x)_x","category":"page"},{"location":"example103/","page":"103: Nonlinear Diffusion equation (DiffEq)","title":"103: Nonlinear Diffusion equation (DiffEq)","text":"for x in Omega=(-11) with homogeneous Neumann boundary conditions using the ODE solvers of the DifferentialEquations.jl package.","category":"page"},{"location":"example103/","page":"103: Nonlinear Diffusion equation (DiffEq)","title":"103: Nonlinear Diffusion equation (DiffEq)","text":"We take for our problem the following initial condition (exact solution named Barenblatt solution):","category":"page"},{"location":"example103/","page":"103: Nonlinear Diffusion equation (DiffEq)","title":"103: Nonlinear Diffusion equation (DiffEq)","text":"u(x0001) = maxleft(0t^-alphaleft(1-fracalpha(m-1)x^22mt^2alpharight)^frac1m-1right)","category":"page"},{"location":"example103/","page":"103: Nonlinear Diffusion equation (DiffEq)","title":"103: Nonlinear Diffusion equation (DiffEq)","text":"for m=2 and alpha = left(m+1right)^-1.","category":"page"},{"location":"example103/","page":"103: Nonlinear Diffusion equation (DiffEq)","title":"103: Nonlinear Diffusion equation (DiffEq)","text":"module Example103_NonlinearDiffusion_DiffEq\n\nusing SkeelBerzins\n\nfunction main()\n\n\tNx = 21\n\n\tL = 1\n\tT = 0.01\n\n\tx_mesh = collect(range(-1,L,length=Nx))\n\ttspan  = (0.001,T)\n\n\tm = 0\n\n\tfunction barenblatt(x,t,p)\n\t\ttx=t^(-1.0/(p+1.0))\n\t\txx=x*tx\n\t\txx=xx*xx\n\t\txx=1- xx*(p-1)/(2.0*p*(p+1));\n\t\tif xx<0.0\n\t\t\txx=0.0\n\t\tend\n\t\treturn tx*xx^(1.0/(p-1.0))\n\tend\n\n\tfunction pdefun(x,t,u,dudx)\n\t\tc = 1\n\t\tf = 2*u*dudx\n\t\ts = 0\n\t\t\n\t\treturn c,f,s\n\tend\n\n\n\tfunction icfun(x)\n\t\tu0 = barenblatt(x,0.001,2)\n\t\t\n\t\treturn u0\n\tend\n\n\n\tfunction bdfun(xl,ul,xr,ur,t)\n\t\tpl = 0\n\t\tql = 1\n\t\tpr = 0\n\t\tqr = 1\n\n\t\treturn pl,ql,pr,qr\n\tend\n\n\tparams = SkeelBerzins.Params()\n\tparams.solver = :DiffEq\n\n\tpb = pdepe(m,pdefun,icfun,bdfun,x_mesh,tspan ; params=params)\n\tproblem = DifferentialEquations.ODEProblem(pb)\n\tsol = DifferentialEquations.solve(problem,Rosenbrock23())\n\n\treturn sum(sol.u[end])\nend\n\n\nfunction test()\n    testval=46.66666666671536\n    main() ≈ testval\nend\n\n\nend","category":"page"},{"location":"example109/#Example-109:-System-of-Reaction-Diffusion-equations-(DiffEq)","page":"109: System of Reaction-Diffusion equations (DiffEq)","title":"Example 109: System of Reaction-Diffusion equations (DiffEq)","text":"","category":"section"},{"location":"example109/","page":"109: System of Reaction-Diffusion equations (DiffEq)","title":"109: System of Reaction-Diffusion equations (DiffEq)","text":"Solve the following system of PDEs:","category":"page"},{"location":"example109/","page":"109: System of Reaction-Diffusion equations (DiffEq)","title":"109: System of Reaction-Diffusion equations (DiffEq)","text":"partial_t u_1 = 05 partial^2_x u_1 - u_1 + u_2 = 0 \npartial_t u_2 = 01 partial^2_x u_2 + u_1 - u_2 = 0 \nu_1(0t) = 1 \npartial_x u_1(1t) = 0 \npartial_x u_2(0t) = 0 \nu_2(0t) = 0","category":"page"},{"location":"example109/","page":"109: System of Reaction-Diffusion equations (DiffEq)","title":"109: System of Reaction-Diffusion equations (DiffEq)","text":"for x in Omega=(010) using the DAE solvers of the DifferentialEquations.jl package.","category":"page"},{"location":"example109/","page":"109: System of Reaction-Diffusion equations (DiffEq)","title":"109: System of Reaction-Diffusion equations (DiffEq)","text":"We take for our problem the following initial condition:","category":"page"},{"location":"example109/","page":"109: System of Reaction-Diffusion equations (DiffEq)","title":"109: System of Reaction-Diffusion equations (DiffEq)","text":"u_1(x0) = 0 \nu_2(x0) = 0","category":"page"},{"location":"example109/","page":"109: System of Reaction-Diffusion equations (DiffEq)","title":"109: System of Reaction-Diffusion equations (DiffEq)","text":"module Example109_SystemReactionDiffusion_DiffEq\n\nusing SkeelBerzins\n\n\nfunction main()\n\n\tN_x = 21\n\t\t\n\tL = 1\n\tT = 10\n\n\tx_mesh = collect(range(0,L,length=N_x))\n\ttspan  = (0, T)\n\n\tm = 0\n\n\tfunction pdefun_test(x,t,u,dudx)\n\t\tc = SVector(1,1)\n\t\tf = SVector(0.5,0.1) .* dudx\n\t\ty = u[1] - u[2]\n\t\ts = SVector(-y, y)\n\t\t\n\t\treturn c,f,s\n\tend\n\n\tfunction icfun_test(x)\n\t\tu0 = SVector(0.0, 0.0)\n\t\t\n\t\treturn u0\n\tend\n\n\n\tfunction bdfun_test(xl,ul,xr,ur,t)\n\t\tpl = SVector(ul[1]-1.0, 0)\n\t\tql = SVector(0, 1)\n\t\tpr = SVector(0, ur[2])\n\t\tqr = SVector(1, 0)\n\n\t\treturn pl,ql,pr,qr\n\tend\n\n\tparams = SkeelBerzins.Params()\n\tparams.solver = :DiffEq\n\n\tpb = pdepe(m,pdefun_test,icfun_test,bdfun_test,x_mesh,tspan ; params=params)\n\tproblem = DifferentialEquations.ODEProblem(pb)\n\tsol = DifferentialEquations.solve(problem,Rosenbrock23())\n\n\treturn sum(sol.u[end])\nend\n\nfunction test()\n    testval=29.035923566365785\n    main() ≈ testval\nend\n\nend","category":"page"},{"location":"example112/#Example-112:-Linear-Diffusion-equation-in-spherical-coordinates","page":"112: Linear Diffusion equation in spherical coordinates","title":"Example 112: Linear Diffusion equation in spherical coordinates","text":"","category":"section"},{"location":"example112/","page":"112: Linear Diffusion equation in spherical coordinates","title":"112: Linear Diffusion equation in spherical coordinates","text":"Solve the following problem:","category":"page"},{"location":"example112/","page":"112: Linear Diffusion equation in spherical coordinates","title":"112: Linear Diffusion equation in spherical coordinates","text":"u_t = frac1x^2(x^2 u_x)_x","category":"page"},{"location":"example112/","page":"112: Linear Diffusion equation in spherical coordinates","title":"112: Linear Diffusion equation in spherical coordinates","text":"for x in Omega=(01) with the imposed symmetry condition in x=0 (since use of spherical coordinates) and Dirichlet condition in x=1 using the implicit Euler method (internal method).","category":"page"},{"location":"example112/","page":"112: Linear Diffusion equation in spherical coordinates","title":"112: Linear Diffusion equation in spherical coordinates","text":"We take for our problem the following initial condition:","category":"page"},{"location":"example112/","page":"112: Linear Diffusion equation in spherical coordinates","title":"112: Linear Diffusion equation in spherical coordinates","text":"u(x0) = x^2","category":"page"},{"location":"example112/","page":"112: Linear Diffusion equation in spherical coordinates","title":"112: Linear Diffusion equation in spherical coordinates","text":"module Example112_LinearDiffusionSpherical\n\nusing SkeelBerzins\nusing LinearAlgebra\n\nfunction main()\n\n    Nx = 21\n    \n    L = 1\n    T = 0.8\n    \n    x_mesh = collect(range(0, L, length=Nx))\n    tspan  = (0.0, T)\n    \n    m = 2\n\n    function pdefun(x,t,u,dudx)\n        c = 1\n        f = dudx\n        s = 0\n        \n        return c,f,s\n    end\n\n    function icfun(x)\n        u0 = x^2\n        \n        return u0\n    end\n\n    function bdfun(xl,ul,xr,ur,t)\n        pl = 0 # ignored by solver since m=1\n        ql = 0 # ignored by solver since m=1\n        pr = ur-(1+6*t)\n        qr = 0\n    \n        return pl,ql,pr,qr\n    end\n\n    sol = pdepe(m,pdefun,icfun,bdfun,x_mesh,tspan)\n\n    exact(x,t) = x^2 + 6*t\n\n    return norm(sol.u[end] - exact.(x_mesh,T)) < 1.0e-2\nend\n\n\nfunction test()\n    main()\nend\n\nend","category":"page"},{"location":"example102/#Example-102:-Linear-Diffusion-equation","page":"102: Linear Diffusion equation","title":"Example 102: Linear Diffusion equation","text":"","category":"section"},{"location":"example102/","page":"102: Linear Diffusion equation","title":"102: Linear Diffusion equation","text":"Solve the following linear diffusion equation:","category":"page"},{"location":"example102/","page":"102: Linear Diffusion equation","title":"102: Linear Diffusion equation","text":"u_t  = u_xx","category":"page"},{"location":"example102/","page":"102: Linear Diffusion equation","title":"102: Linear Diffusion equation","text":"for x in Omega=(01) with homogeneous Neumann boundary conditions using the implicit Euler method (internal method).","category":"page"},{"location":"example102/","page":"102: Linear Diffusion equation","title":"102: Linear Diffusion equation","text":"We take for our problem the following initial condition:","category":"page"},{"location":"example102/","page":"102: Linear Diffusion equation","title":"102: Linear Diffusion equation","text":"u(x0) = exp(-100*(x-025)^2)","category":"page"},{"location":"example102/","page":"102: Linear Diffusion equation","title":"102: Linear Diffusion equation","text":"module Example102_LinearDiffusion\n\nusing SkeelBerzins\n\n\nfunction main()\n\n\tN_x = 21\n\t\t\n\tL = 1\n\tT = 1\n\n\tx_mesh = collect(range(0,L,length=N_x))\n\ttspan  = (0, T)\n\n\tm = 0\n\t\n\tfpeak(x)=exp(-100*(x-0.25)^2)\n\n\tfunction pdefun(x,t,u,dudx)\n\t\tc = 1\n\t\tf = dudx \n\t\ts = 0\n\t\t\n\t\treturn c,f,s\n\tend\n\n\tfunction icfun(x)\n\t\tu0 = fpeak(x)\n\t\t\n\t\treturn u0\n\tend\n\n\n\tfunction bdfun(xl,ul,xr,ur,t)\n\t\tpl = 0\n\t\tql = 1\n\t\tpr = 0\n\t\tqr = 1\n\n\t\treturn pl,ql,pr,qr\n\tend\n\n\tsol = pdepe(m,pdefun,icfun,bdfun,x_mesh,tspan)\n\t\n\n\treturn sum(sol.u[end])\nend\n\nfunction test()\n    testval=3.721004873950427\n    main() ≈ testval\nend\n\n\nend","category":"page"},{"location":"example108/#Example-108:-Stationary-nonlinear-diffusion-equation","page":"108: Stationary nonlinear diffusion equation","title":"Example 108: Stationary nonlinear diffusion equation","text":"","category":"section"},{"location":"example108/","page":"108: Stationary nonlinear diffusion equation","title":"108: Stationary nonlinear diffusion equation","text":"Solve the following nonlinear diffusion equation:","category":"page"},{"location":"example108/","page":"108: Stationary nonlinear diffusion equation","title":"108: Stationary nonlinear diffusion equation","text":"-(2uu_x)_x = 1 \nu(0) = 01 \nu(1) = 01 ","category":"page"},{"location":"example108/","page":"108: Stationary nonlinear diffusion equation","title":"108: Stationary nonlinear diffusion equation","text":"for x in Omega=(01) with inhomogeneous Dirichlet boundary conditions using the implicit Euler method (internal method).","category":"page"},{"location":"example108/","page":"108: Stationary nonlinear diffusion equation","title":"108: Stationary nonlinear diffusion equation","text":"module Example108_StationaryNonLinearDiffusion\n\nusing SkeelBerzins\n\n\nfunction main()\n\n\tN_x = 21\n\t\t\n\tL = 1\n\tT = 1\n\n\tx_mesh = collect(range(0,L,length=N_x))\n\ttspan  = (0, T)\n\n\tm = 0\n\n\tfunction pdefun_test(x,t,u,dudx)\n\t\tc = 1\n\t\tf = 2*u*dudx \n\t\ts = 1\n\t\t\n\t\treturn c,f,s\n\tend\n\n\tfunction icfun_test(x)\n\t\tu0 = 0.1\n\t\t\n\t\treturn u0\n\tend\n\n\n\tfunction bdfun_test(xl,ul,xr,ur,t)\n\t\tpl = ul - 0.1\n\t\tql = 0\n\t\tpr = ur - 0.1\n\t\tqr = 0\n\n\t\treturn pl,ql,pr,qr\n\tend\n\n\tparams = SkeelBerzins.Params()\n\tparams.tstep = Inf\n\n\tsol = pdepe(m,pdefun_test,icfun_test,bdfun_test,x_mesh,tspan ; params=params)\n\t\n\n\treturn sum(sol)\nend\n\nfunction test()\n    testval=6.025575019008793\n    main() ≈ testval\nend\n\nend","category":"page"},{"location":"example105/#Example-105:-Linear-Diffusion-equation-in-cylindrical-coordinates-(DiffEq)","page":"105: Linear Diffusion equation in cylindrical coordinates (DiffEq)","title":"Example 105: Linear Diffusion equation in cylindrical coordinates (DiffEq)","text":"","category":"section"},{"location":"example105/","page":"105: Linear Diffusion equation in cylindrical coordinates (DiffEq)","title":"105: Linear Diffusion equation in cylindrical coordinates (DiffEq)","text":"Solve the following problem:","category":"page"},{"location":"example105/","page":"105: Linear Diffusion equation in cylindrical coordinates (DiffEq)","title":"105: Linear Diffusion equation in cylindrical coordinates (DiffEq)","text":"u_t = frac1x(xu_x)_x","category":"page"},{"location":"example105/","page":"105: Linear Diffusion equation in cylindrical coordinates (DiffEq)","title":"105: Linear Diffusion equation in cylindrical coordinates (DiffEq)","text":"for x in Omega=(01) with the imposed symmetry condition in x=0 (since use of cylindrical coordinates) and Dirichlet condition in x=1 using the DAE solvers of the DifferentialEquations.jl package.","category":"page"},{"location":"example105/","page":"105: Linear Diffusion equation in cylindrical coordinates (DiffEq)","title":"105: Linear Diffusion equation in cylindrical coordinates (DiffEq)","text":"We initialize our problem with the exact solution (Bessel function and its first zero):","category":"page"},{"location":"example105/","page":"105: Linear Diffusion equation in cylindrical coordinates (DiffEq)","title":"105: Linear Diffusion equation in cylindrical coordinates (DiffEq)","text":"u(x0) = J_0(nx)","category":"page"},{"location":"example105/","page":"105: Linear Diffusion equation in cylindrical coordinates (DiffEq)","title":"105: Linear Diffusion equation in cylindrical coordinates (DiffEq)","text":"where n = 2404825557695773.","category":"page"},{"location":"example105/","page":"105: Linear Diffusion equation in cylindrical coordinates (DiffEq)","title":"105: Linear Diffusion equation in cylindrical coordinates (DiffEq)","text":"module Example105_LinearDiffusionCylindrical_DiffEq\n\nusing SkeelBerzins\nusing SpecialFunctions\n\nfunction main()\n\n    Nx = 21\n    \n    L = 1\n    T = 1\n    \n    x_mesh = collect(range(0, L, length=Nx))\n    tspan  = (0, T)\n    \n    m = 1\n\n    function pdefun(x,t,u,dudx)\n        c = 1\n        f = dudx\n        s = 0\n        \n        return c,f,s\n    end\n\n    function icfun(x)\n        n = 2.404825557695773\n        u0 = besselj(0,n*x)\n        \n        return u0\n    end\n\n    function bdfun(xl,ul,xr,ur,t)\n        n  = 2.404825557695773\n        pl = 0 # ignored by solver since m=1\n        ql = 0 # ignored by solver since m=1\n        pr = ur-besselj(0,n)*exp(-n^2*t)\n        qr = 0\n\n        return pl,ql,pr,qr\n    end\n\n    params = SkeelBerzins.Params()\n    params.solver = :DiffEq\n\n    pb = pdepe(m,pdefun,icfun,bdfun,x_mesh,tspan ; params=params)\n    problem = DifferentialEquations.ODEProblem(pb)\n    sol = DifferentialEquations.solve(problem,Rosenbrock23())\n\n    return sum(sol.u[end])\nend\n\n\nfunction test()\n    testval = 0.03902519717606674\n    main() ≈ testval\nend\n\nend","category":"page"},{"location":"example106/#Example-106:-Linear-Diffusion-equation-cylindrical-coordinates","page":"106: Linear Diffusion equation cylindrical coordinates","title":"Example 106: Linear Diffusion equation cylindrical coordinates","text":"","category":"section"},{"location":"example106/","page":"106: Linear Diffusion equation cylindrical coordinates","title":"106: Linear Diffusion equation cylindrical coordinates","text":"Solve the following problem:","category":"page"},{"location":"example106/","page":"106: Linear Diffusion equation cylindrical coordinates","title":"106: Linear Diffusion equation cylindrical coordinates","text":"u_t = frac1x(xu_x)_x","category":"page"},{"location":"example106/","page":"106: Linear Diffusion equation cylindrical coordinates","title":"106: Linear Diffusion equation cylindrical coordinates","text":"for x in Omega=(01) with the imposed symmetry condition in x=0 (since use of cylindrical coordinates) and Dirichlet condition in x=1 using the implicit Euler method (internal method).","category":"page"},{"location":"example106/","page":"106: Linear Diffusion equation cylindrical coordinates","title":"106: Linear Diffusion equation cylindrical coordinates","text":"We initialize our problem with the exact solution (Bessel function and its first zero):","category":"page"},{"location":"example106/","page":"106: Linear Diffusion equation cylindrical coordinates","title":"106: Linear Diffusion equation cylindrical coordinates","text":"u(x0) = J_0(nx)","category":"page"},{"location":"example106/","page":"106: Linear Diffusion equation cylindrical coordinates","title":"106: Linear Diffusion equation cylindrical coordinates","text":"where n = 2404825557695773.","category":"page"},{"location":"example106/","page":"106: Linear Diffusion equation cylindrical coordinates","title":"106: Linear Diffusion equation cylindrical coordinates","text":"module Example106_LinearDiffusionCylindrical\n\nusing SkeelBerzins\nusing SpecialFunctions\n\nfunction main()\n\n    Nx = 21\n    \n    L = 1\n    T = 1\n    \n    x_mesh = collect(range(0, L, length=Nx))\n    tspan  = (0, T)\n    \n    m = 1\n\n    function pdefun(x,t,u,dudx)\n        c = 1\n        f = dudx\n        s = 0\n        \n        return c,f,s\n    end\n\n    function icfun(x)\n        n = 2.404825557695773\n        u0 = besselj(0,n*x)\n        \n        return u0\n    end\n\n    function bdfun(xl,ul,xr,ur,t)\n        n  = 2.404825557695773\n        pl = 0 # ignored by solver since m=1\n        ql = 0 # ignored by solver since m=1\n        pr = ur-besselj(0,n)*exp(-n^2*t)\n        qr = 0\n\n        return pl,ql,pr,qr\n    end\n\n    sol = pdepe(m,pdefun,icfun,bdfun,x_mesh,tspan)\n\n    return sum(sol.u[end])\nend\n\n\nfunction test()\n    testval = 0.04020183138531086\n    main() ≈ testval\nend\n\nend","category":"page"},{"location":"performance/#Achieve-Performance","page":"Achieve performance","title":"Achieve Performance","text":"","category":"section"},{"location":"performance/#Using-StaticArrays.jl","page":"Achieve performance","title":"Using StaticArrays.jl","text":"","category":"section"},{"location":"performance/","page":"Achieve performance","title":"Achieve performance","text":"One way to improve the performance of the package when solving system of PDEs, is to use the StaticArrays.jl package to define the PDE formulation.","category":"page"},{"location":"performance/","page":"Achieve performance","title":"Achieve performance","text":"This package allows you to use arrays that are stored on the stack rather than on the heap, which eliminates the need for memory allocation when defining and evaluating the problem. In contrast, when using arrays to define the problem, it creates heap-allocations for every interval where the function is evaluated.","category":"page"},{"location":"performance/#Example","page":"Achieve performance","title":"Example","text":"","category":"section"},{"location":"performance/","page":"Achieve performance","title":"Achieve performance","text":"using SkeelBerzins\n\n# Define symmetry of the problem\nm = 0\n\n# Define PDE Formulation\nfunction pdefunction(x,t,u,dudx)\n    c = SVector(1,1)\n    f = SVector(0.5,0.1) .* dudx\n    y = u[1] - u[2]\n    s = SVector(-y, y)\n\n    c,f,s\nend\n\n# Define the initial condition\nfunction icfunction(x)\n    u0 = SVector(0.0, 0.0)\n    \n    u0\nend\n\n# Define the boundary condtions\nfunction bdfunction(xl,ul,xr,ur,t)\n    pl = SVector(ul[1]-1.0, 0)\n    ql = SVector(0, 1)\n    pr = SVector(0, ur[2])\n    qr = SVector(1, 0)\n\n    pl,ql,pr,qr\nend\n\n# Define the spatial discretization\nxmesh = collect(range(0,1,length=21))\n\n# Define the time interval\ntspan = (0,10)\n\n# Define Keyword Arguments\nparams = SkeelBerzins.Params()\nparams.tstep = 1e-2\n\n# Solve\nsol = pdepe(m,pdefunction,icfunction,bdfunction,xmesh,tspan ; params=params)","category":"page"},{"location":"solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Now that we have an understanding of the overall problem definition, we can look into the various solvers included in the package and investigate their specific input and output parameters in detail.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"The solvers expect the PDE problem to be described in the following way.","category":"page"},{"location":"solvers/#Define-the-PDE","page":"Solvers","title":"Define the PDE","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"In order to define the PDE(s), we have to follow the format introduced in the previous section on Problem definition. For the purpose of this explanation, we use the function pdefunction(x,t,u,dudx) to describe the PDE(s). The inputs of the function are self-explanatory. It will then returns the capacity c(x,t,u,dudx), the flux f(x,t,u,dudx) and the source s(x,t,u,dux) terms.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"This function will be passed as an argument to the solver.","category":"page"},{"location":"solvers/#Define-the-initial-conditions","page":"Solvers","title":"Define the initial conditions","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"To define the initial condition(s), we introduce the function icfunction(x). For problems that contain at least one parabolic equation, it will return the evaluation of the initial condition on the spatial mesh xmesh at the initial time t_0.\nFor stationary problems it will return the evaluation of the initial value on the spatial mesh xmesh used for the newton solver.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"This function will be passed as an argument to the solver.","category":"page"},{"location":"solvers/#Define-the-boundary-conditions","page":"Solvers","title":"Define the boundary conditions","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"To represent the boundary condition, we introduce the function bdfunction(xl,ul,xr,ur,t). The input arguments are:","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"xl: left boundary point of the problem.\nul: estimate of the solution evaluated at the left boundary of the domain.\nxr: right boundary point of the problem.\nur: estimate of the solution evaluated at the right boundary of the domain.\nt: evaluates the boundary conditions at time t in t_0t_end.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"The function will return the terms of the boundary conditions introduced in the problem defintion section, i.e. p(x,t,u) and q(x,t) for the left and right part of the spatial mesh.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"warning: Warning\nIf m0 and the left boundary point of the domain a=0, the solver ignores the given boundary condition to enforce the symmetry condition    resulting in a more accurate solution near x=0.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"This function will be passed as an argument to the solver.","category":"page"},{"location":"solvers/#Obtaining-Solutions","page":"Solvers","title":"Obtaining Solutions","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Having defined the PDE formulation, the solver function pdepe can now be introduced. Look pdepe.","category":"page"},{"location":"solvers/#Internal-method:-implicit-Euler-method","page":"Solvers","title":"Internal method: implicit Euler method","text":"","category":"section"},{"location":"solvers/#Parabolic-equation(s)","page":"Solvers","title":"Parabolic equation(s)","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"The package contains an implementation of the implicit Euler method which can be used to solve parabolic equation(s). The method has a first order error with respect to time.","category":"page"},{"location":"solvers/#Elliptic-Equations","page":"Solvers","title":"Elliptic Equations","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Only the internal method can be used to solve stationary problems and it is written in the following manner:","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"M fracu^k+1-u^kDelta t = A(u^k+1)","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"with M the mass matrix, Delta t the time step used for the time discretization, A the (non)linear operator resulting from the space discretization, u^k and u^k+1 the estimate solutions at time t_0 + k Delta t and t_0 + (k+1) Delta t respectively.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"In Julia, positive infinity is defined as Inf. By setting Delta t = Inf, it follows that frac1Delta t = 0 and thus we are left with the stationary problem which can solved by using the Newton solver (see SkeelBerzins.newton).","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"It results that the solution for the stationary problem can be obtained by running one iteration of the implicit Euler method.","category":"page"},{"location":"solvers/#Solve-with-DifferentialEquations.jl","page":"Solvers","title":"Solve with DifferentialEquations.jl","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"SkeelBerzins.jl is also compatible with the DifferentialEquations.jl package.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"It is possible to return the data from the problem in a SkeelBerzins.ProblemDefinition structure, then to define an ODEFunction, an ODEProblem and solve it using any ODE/DAE solvers from DifferentialEquations.jl.","category":"page"},{"location":"solvers/#Examples","page":"Solvers","title":"Examples","text":"","category":"section"},{"location":"solvers/#Solve-linear-diffusion-problem-in-cartesian-coordinates-with-homogeneous-Neumann-boundary-conditions-using-internal-implicit-Euler-method","page":"Solvers","title":"Solve linear diffusion problem in cartesian coordinates with homogeneous Neumann boundary conditions using internal implicit Euler method","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"using SkeelBerzins\n\n# Define symmetry of the problem\nm = 0\n\n# Define PDE Formulation\nfunction pdefunction(x,t,u,dudx)\n    c = 1\n    f = dudx\n    s = 0\n\n    c,f,s\nend\n\n# Define the initial condition\nicfunction(x) = exp(-100*(x-0.25)^2)\n\n# Define the boundary condtions\nfunction bdfunction(xl,ul,xr,ur,t)\n    pl = 0\n    ql = 1\n    pr = 0\n    qr = 1\n\n    pl,ql,pr,qr\nend\n\n# Define the spatial discretization\nxmesh = collect(range(0,1,length=21))\n\n# Define the time interval\ntspan = (0,1)\n\n# Solve\nsol = pdepe(m,pdefunction,icfunction,bdfunction,xmesh,tspan)","category":"page"},{"location":"solvers/#Solve-linear-diffusion-problem-in-cartesian-coordinates-with-homogeneous-Neumann-boundary-conditions-using-the-DifferentialEquations.jl","page":"Solvers","title":"Solve linear diffusion problem in cartesian coordinates with homogeneous Neumann boundary conditions using the DifferentialEquations.jl","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"using SkeelBerzins\n\n# Define symmetry of the problem\nm = 0\n\n# Define PDE Formulation\nfunction pdefunction(x,t,u,dudx)\n    c = 1\n    f = dudx\n    s = 0\n\n    c,f,s\nend\n\n# Define the initial condition\nicfunction(x) = exp(-100*(x-0.25)^2)\n\n# Define the boundary condtions\nfunction bdfunction(xl,ul,xr,ur,t)\n    pl = 0\n    ql = 1\n    pr = 0\n    qr = 1\n\n    pl,ql,pr,qr\nend\n\n# Define the spatial discretization\nxmesh = collect(range(0,1,length=21))\n\n# Define the time interval\ntspan = (0,1)\n\n# Define Keyword Arguments\nparams = SkeelBerzins.Params()\nparams.solver = :DiffEq\n\n# Solve\nproblem_data = pdepe(m,pdefunction,icfunction,bdfunction,xmesh,tspan ; params=params)\nproblem_ode = DifferentialEquations.ODEProblem(problem_data)\nsol_ode = DifferentialEquations.solve(problem,Rosenbrock23())\nsol = reshape(sol_ode,problem_data)","category":"page"},{"location":"public_private_APIs/#Public-and-private-APIs","page":"Public and Private APIs","title":"Public and private APIs","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"We present here an index of all the methods that are present in the package. These are separated into two classes:","category":"page"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"Public API\nPrivate API","category":"page"},{"location":"public_private_APIs/#Public-API","page":"Public and Private APIs","title":"Public API","text":"","category":"section"},{"location":"public_private_APIs/#Solvers","page":"Public and Private APIs","title":"Solvers","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"pdepe","category":"page"},{"location":"public_private_APIs/#SkeelBerzins.pdepe","page":"Public and Private APIs","title":"SkeelBerzins.pdepe","text":"pdepe(m, pdefunction, icfunction, bdfunction, xmesh, tspan ; params=nothing)\n\nSolve 1D elliptic and/or parabolic partial differential equation(s) using the spatial discretization method described in [1]. The time discretization is either done by the implicit Euler method (internal method) or by using a ODE/DAE solver from the DifferentialEquations.jl package. For more information on how to define the different inputs to solve a problem, look at the following sections: Problem Definition and Solvers.\n\nInput arguments:\n\nm: scalar refering to the symmetry of the problem. It can either take the value m=0, m=1 or m=2 representing       cartesian, cylindrical or spherical coordinates respectively.\npdefunction: Function. Defines the PDE(s) formulation that incorporates capacity, flux and source terms.\nicfunction: Function. Defines the initial condition of the system to solve (if tstepneqInf - initial condition from the ODE/DAE problem,                else if tstep = Inf - initial value used for the newton solver).\nbdfunction: Function. Defines the boundary conditions of the problem.\nxmesh: one-dimensional array representing the mesh on which the user wants to obtain the solution.\ntspan: tuple (t_0 t_end) representing the time interval of the problem.\n\nKeyword argument:\n\nparams: defines a SkeelBerzins.Params structure containing the keyword arguments from the solvers.\n\nReturns a RecursiveArrayTools.DiffEqArray, a SkeelBerzins.ProblemDefinition structure or a 1D Array, depending on the chosen solver. Moreover, if the solution is obtained from a time dependent problem, a linear interpolation method can be use to evaluate the solution  at any time step within the interval (t_0t_end) (accessible using sol(t)). An interpolation similar as the pdeval function is available on the solution object using the command sol(x_eval,t,pb).\n\n\n\n\n\npdepe(m, pdefunction, icfunction, bdfunction, xmesh ; params=nothing)\n\nSolve 1D elliptic PDE(s) using the spatial discretization method described in [1] - pdepe variant to solve stationary problems. Performs one step of the implicit Euler method. For more information, look at link implicit Euler...\n\nInput arguments:\n\nm: scalar refering to the symmetry of the problem. It can either take the value m=0, m=1 or m=2 representing       cartesian, cylindrical or spherical coordinates respectively.\npdefunction: Function. Defines the PDE(s) formulation which includes the capacity, flux and source terms (capacity term should be set to 0).\nicfunction: Function. It defines the initial value used for the Newton solver.\nbdfunction: Function. Defines the boundary conditions of the problem.\nxmesh: one-dimensional array representing the mesh on which the user wants to obtain the solution.\n\nKeyword argument:\n\nparams: defines a SkeelBerzins.Params structure containing the keyword arguments from the solvers.\n\nReturns a 1D Array with the solution at the points from the spatial discretization xmesh.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#Parameters-for-the-package","page":"Public and Private APIs","title":"Parameters for the package","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"Params","category":"page"},{"location":"public_private_APIs/#SkeelBerzins.Params","page":"Public and Private APIs","title":"SkeelBerzins.Params","text":"mutable struct Params\n\nMutable structure containing all the keyword arguments for the solver pdepe.\n\nsolver::Symbol: Choice of the time discretization either use :euler for internal implicit Euler method or :DiffEq for the DifferentialEquations.jl package.\n\ntstep::Union{Float64, Vector{Float64}}: Defines a time step (either pass a Float64 or a Vector) when using the implicit Euler method. When set to tstep=Inf, it solves the stationary version of the problem.\n\nhist::Bool: Flag, returns with the solution, a list of 1d-array with the history from the newton solver.\n\nsparsity::Symbol: Choice of the type of matrix (:sparseArrays, :exSparse, :banded) use to store the jacobian.\n\nlinSolver::Union{Nothing, LinearSolve.SciMLLinearSolveAlgorithm}: Choice of the solver for the LSE in the newton method, see LinearSolve.jl.\n\nmaxit::Int64: Maximum number of iterations for the Newton solver.\n\ntol::Float64: Tolerance used for Newton method. Returns solution if  u_i+1 - u_i _2  tol.\n\ndata::Bool: Returns the data of the PDE problem\n\n\n\n\n\n","category":"type"},{"location":"public_private_APIs/#Compatibility-with-DifferentialEquations.jl","page":"Public and Private APIs","title":"Compatibility with DifferentialEquations.jl","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"DifferentialEquations.ODEProblem\nBase.reshape","category":"page"},{"location":"public_private_APIs/#SciMLBase.ODEProblem","page":"Public and Private APIs","title":"SciMLBase.ODEProblem","text":"ODEProblem(problem,callback=DifferentialEquations.CallbackSet())\n\nGenerate an ODEProblem from the ODEFunction which then can be solved by using the DifferentialEquations.solve() method.\n\nInput arguments:\n\nproblem: Structure of type SkeelBerzins.ProblemDefinition.\ncallback: (optional) see callback.\n\n\n\n\n\n","category":"type"},{"location":"public_private_APIs/#Base.reshape","page":"Public and Private APIs","title":"Base.reshape","text":"reshape(sol_ODE, problem)\n\nReshape the solution sol_ODE obtained by the DifferentialEquations.jl package to obtain the solution at time t as a 2D-Array of size (npde,Nx). \n\nIndeed since in the spatial discretization, we flattened the problem, the solution has a similar size.  So by reshaping the solution, we get a solution organised by unknows.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#Interpolation-of-the-obtained-solution","page":"Public and Private APIs","title":"Interpolation of the obtained solution","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"pdeval","category":"page"},{"location":"public_private_APIs/#SkeelBerzins.pdeval","page":"Public and Private APIs","title":"SkeelBerzins.pdeval","text":"pdeval(m, xmesh, u_approx, x_eval, pb)\n\nFunction that interpolates with respect to the space component the solution obtained by the solver function pdepe.\n\nInput arguments:\n\nm: symmetry of the problem (m=0,1,2 for cartesian, cylindrical or spherical).\nxmesh: space discretization.\nu_approx: approximate solution obtained by the solver pdepe.\nx_eval: point or vector of points where to interpolate the approximate solution.\npb: structure defining the problem definition, see SkeelBerzins.ProblemDefinition.\n\nReturns a tuple (ududx) corresponding to the solution and its partial derivative with respect to the space component evaluated in x_eval.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#Private-API","page":"Public and Private APIs","title":"Private API","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"These methods should only be considered for developers or people trying to understand the inner workings of the package.","category":"page"},{"location":"public_private_APIs/#Spatial-Discretization","page":"Public and Private APIs","title":"Spatial Discretization","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"SkeelBerzins.assemble!\nSkeelBerzins.interpolation\nSkeelBerzins.interpolation!","category":"page"},{"location":"public_private_APIs/#SkeelBerzins.assemble!","page":"Public and Private APIs","title":"SkeelBerzins.assemble!","text":"assemble!(du, u, problem, t)\n\nPerforms space discretization following the difference equations described in [1].\n\nAssemble the right-hand side f to generate an ODE/DAE problem:\n\n(M) fracdudt = f(uproblemt)\n\nwhere the input problem is defined as a SkeelBerzins.ProblemDefinition structure.\n\nThis function is specified in a way that it is compatible with the DifferentialEquations.jl package.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#SkeelBerzins.interpolation","page":"Public and Private APIs","title":"SkeelBerzins.interpolation","text":"interpolation(xl, ul, xr, ur, quadrature_point, problem)\n\nInterpolate u and fracdudx between two discretization points at some specific quadrature point.\n\nInput arguments:\n\nxl: left boundary of the current interval.\nul: solution evaluated at the left boundary of the current interval.\nxr: right boundary of the current interval.\nur: solution evaluated at the right boundary of the current interval.\nquadrature_point: quadrature point chosen according to the method described in [1].\nproblem: Structure of type SkeelBerzins.ProblemDefinition.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#SkeelBerzins.interpolation!","page":"Public and Private APIs","title":"SkeelBerzins.interpolation!","text":"interpolation!(interp, d_interp, xl, ul, xr, ur, quadrature_point, problem)\n\nMutating version of the interpolation function.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#Newton-solvers","page":"Public and Private APIs","title":"Newton solvers","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"SkeelBerzins.newton\nSkeelBerzins.newton_stat","category":"page"},{"location":"public_private_APIs/#SkeelBerzins.newton","page":"Public and Private APIs","title":"SkeelBerzins.newton","text":"newton(b, tau, timeStep, problem, mass_matrix, cache, rhs ; tol=1.0e-10, maxit=100, hist_flag=false, linSol=nothing)\n\nNewton method solving nonlinear system of equations. The Jacobi matrix used for the iteration rule is computed with the help of the SparseDiffTools.jl package.\n\nInput arguments:\n\nb: right-hand side of the system to solve.\ntau: constant time step used for the time discretization.\ntimeStep: current time step of tspan.\nproblem: Structure of type SkeelBerzins.ProblemDefinition.\nmass_matrix: mass matrix of the problem, see [SkeelBerzins.mass_matrix][@ref].\ncache: SparseDiffTools.ForwardColorCache. To avoid allocating the cache in each iteration of the newton solver when computing the jacobian.\nrhs: preallocated vector to avoid creating allocations.\n\nKeyword arguments:\n\ntol: tolerance or stoppping criteria (by default to 1.0e-10).\nmaxit: maximum number of iterations (by default to 100).\nhist_flag: flag to save the history and returns it (by default to false).\nlinSol: choice of the solver for the LSE, see LinearSolve.jl (by default nothing).\n\nReturns the solution of the nonlinear system of equations and if hist_flag=true, the history of the solver.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#SkeelBerzins.newton_stat","page":"Public and Private APIs","title":"SkeelBerzins.newton_stat","text":"newton_stat(b, tau, timeStep, problem, cache, rhs ; tol=1.0e-10, maxit=100, hist_flag=false, linSol=nothing)\n\nNewton method solving nonlinear system of equations (variant of newton for stationary problems).\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#Problem-definition","page":"Public and Private APIs","title":"Problem definition","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"SkeelBerzins.ProblemDefinition","category":"page"},{"location":"public_private_APIs/#SkeelBerzins.ProblemDefinition","page":"Public and Private APIs","title":"SkeelBerzins.ProblemDefinition","text":"mutable struct ProblemDefinition{T, Tv<:Number, Ti<:Integer, Tm<:Number, pdeFunction<:Function, icFunction<:Function, bdFunction<:Function}\n\nMutable structure storing the problem definition.\n\nnpde::Integer: Number of unknowns\n\nNx::Integer: Number of discretization points\n\nxmesh::Vector{Tv} where Tv<:Number: Grid of the problem\n\ntspan::Tuple{Tm, Tm} where Tm<:Number: Time interval\n\nsingular::Bool: Flag to know if the problem is singular or not\n\nm::Integer: Symmetry of the problem\n\njac::Union{SparseArrays.SparseMatrixCSC{Tv, Ti}, BandedMatrices.BandedMatrix{Tv}} where {Tv<:Number, Ti<:Integer}: Jacobi matrix\n\ninival::Vector{Tv} where Tv<:Number: Evaluation of the initial condition\n\nξ::Vector{Tv} where Tv<:Number: Interpolation points from the paper\n\nζ::Vector{Tv} where Tv<:Number\npdefunction::Function: Function defining the coefficients of the PDE\n\nicfunction::Function: Function defining the initial condition\n\nbdfunction::Function: Function defining the boundary conditions\n\ninterpolant::Vector{Tv} where Tv<:Number: Preallocated vectors for interpolation in assemble! function when solving system of PDEs\n\nd_interpolant::Vector{Tv} where Tv<:Number\n\n\n\n\n\n","category":"type"},{"location":"public_private_APIs/#Implicit-Euler-method","page":"Public and Private APIs","title":"Implicit Euler method","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"SkeelBerzins.implicitEuler!\nSkeelBerzins.implicitEuler_stat!\nSkeelBerzins.mass_matrix","category":"page"},{"location":"public_private_APIs/#SkeelBerzins.implicitEuler!","page":"Public and Private APIs","title":"SkeelBerzins.implicitEuler!","text":"implicitEuler!(y,u,problem,tau,mass_matrix,timeStep)\n\nAssemble the system for the implicit Euler method.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#SkeelBerzins.implicitEuler_stat!","page":"Public and Private APIs","title":"SkeelBerzins.implicitEuler_stat!","text":"implicitEuler_stat!(y,u,problem,tau,timeStep)\n\nAssemble the system for the implicit Euler method (variant method for stationary problems).\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#SkeelBerzins.mass_matrix","page":"Public and Private APIs","title":"SkeelBerzins.mass_matrix","text":"mass_matrix(problem)\n\nAssemble the diagonal mass matrix M of the system of differential equations  when solving a problem with at least one parabolic PDE. The coefficients from M either take the value 0 or 1 since it is scaled in the  difference equations in the right-hand side.\n\nThe entries of the matrix are set to 0 when the corresponding equation of the system is elliptic or the boundary condition is pure Dirichlet leading to solve a Differential-Algebraic system of Equations. In the case where the mass matrix is identity, we solve a system of ODEs.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#Post-processing","page":"Public and Private APIs","title":"Post-processing","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"SkeelBerzins.interpolate_sol_time\nSkeelBerzins.interpolate_sol_space","category":"page"},{"location":"public_private_APIs/#SkeelBerzins.interpolate_sol_time","page":"Public and Private APIs","title":"SkeelBerzins.interpolate_sol_time","text":"interpolate_sol_time(u_approx,t)\n\nLinear interpolatation of the solution with respect to the time component.\n\nInput arguments:\n\nu_approx: approximate solution obtained by the solver pdepe.\nt: time t in t_0t_end.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#SkeelBerzins.interpolate_sol_space","page":"Public and Private APIs","title":"SkeelBerzins.interpolate_sol_space","text":"interpolate_sol_space(u_approx, x_eval, pb, times ; val=true, deriv=true)\n\nSimilar as pdeval, i.e. interpolate the solution and its derivative with respect to the space component.\n\nInput arguments:\n\nu_approx: approximate solution obtained by the solver pdepe.\nx_eval: point or vector of points where to interpolate the approximate solution.\ntimes: point or vector of points which denotes the time step of the solution.\npb: structure defining the problem definition, see SkeelBerzins.ProblemDefinition.\n\nKeyword arguments:\n\nval: flag to return the evaluation of the solution at the x_eval position.\nderiv: flag to return the derivative with respect to the space component  of the solution at the x_eval position.\n\nReturns a tuple (ududx) corresponding to the solution and its partial derivative with respect to the space component evaluated in x_eval at time times.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#Compatibility-with-DifferentialEquations.jl-2","page":"Public and Private APIs","title":"Compatibility with DifferentialEquations.jl","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"The ODEFunction constructor is implicitely defined in the ODEProblem and so doesn't need to be considered by the user to solve the problem with the DifferentialEquations.jl package.","category":"page"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"DifferentialEquations.ODEFunction","category":"page"},{"location":"public_private_APIs/#SciMLBase.ODEFunction","page":"Public and Private APIs","title":"SciMLBase.ODEFunction","text":"ODEFunction(problem)\n\nGenerate an ODEFunction  from the spatial discretization derived in the assemble! function. It is expressed as a mass matrix ODE if the mass matrix is different from the identity matrix or as a simple system of ODEs otherwise and defines the problem with respect to the sparsity pattern.\n\nInput argument:\n\nproblem: Structure of type SkeelBerzins.ProblemDefinition.\n\n\n\n\n\n","category":"type"},{"location":"example301/#Example-301:-PDE-Constrained-Optimization","page":"301: PDE Constrained Optimization","title":"Example 301: PDE Constrained Optimization","text":"","category":"section"},{"location":"example301/","page":"301: PDE Constrained Optimization","title":"301: PDE Constrained Optimization","text":"This example is used to show the integration of the package in the SciML ecosystem. For more details on the problem, look at the following link: https://docs.sciml.ai/SciMLSensitivity/stable/examples/pde/pde_constrained/.","category":"page"},{"location":"example301/","page":"301: PDE Constrained Optimization","title":"301: PDE Constrained Optimization","text":"module Example301_SciMLSensitivityIntegration\nusing SkeelBerzins\n\nusing DelimitedFiles\nusing Optimization, OptimizationPolyalgorithms, OptimizationOptimJL, SciMLSensitivity\n\nfunction f(p)\n\n    # Problem setup parameters:\n    m = 0\n    Lx = 10.0\n    x  = 0.0:0.01:Lx\n    dx = x[2] - x[1]\n\n    # Problem Parameters\n    dt       = 0.40*dx^2    # CFL condition\n    t0, tMax = 0.0 ,1000*dt\n    tspan    = (t0,tMax)\n    t        = t0:dt:tMax\n\n    a0, a1 = p\n\n    function pdefun(x,t,u,dudx)\n        c = 1\n        f = a1*dudx\n        s = 2.0*a0*u\n\n        c,f,s\n    end\n\n    icfun(x) = exp(-(x-3.0)^2)\n\n    function bcfun(xl,ul,xr,ur,t)\n        pl = ul \n        ql = 0\n        pr = ur\n        qr = 0\n\n        pl,ql,pr,qr\n    end\n\n    params_pdepe = SkeelBerzins.Params()\n    params_pdepe.solver = :DiffEq\n\n    pb = pdepe(m,pdefun,icfun,bcfun,collect(x),tspan ; params=params_pdepe)\n    prob = DifferentialEquations.ODEProblem(pb)\n    sol = DifferentialEquations.solve(prob,RadauIIA3(linsolve = SparspakFactorization()), dt=dt,saveat=t)\n\n    sol\nend\n\nfunction main()\n    p       = [1.0,1.0] # True solution parameters\n    sol_exact = f(p)\n\n    # Building the Prediction Model\n    ps  = [0.1, 0.2]  # Initial guess for model parameters\n    function predict(θ)\n        sol = f(θ)\n        Array(sol)\n    end\n\n    # Defining Loss function\n    function loss(θ)\n        pred = predict(θ)\n        l = predict(θ)  - sol_exact\n        return sum(abs2, l), pred # Mean squared error\n    end\n\n    LOSS  = []     # Loss accumulator\n    PRED  = []     # prediction accumulator\n    PARS  = []     # parameters accumulator\n\n    callback = function (θ,l,pred) # callback function to observe training\n        # display(l)\n        append!(PRED, [pred])\n        append!(LOSS, l)\n        append!(PARS, [θ])\n        false\n    end\n\n\n    adtype = Optimization.AutoForwardDiff() # see https://docs.sciml.ai/Optimization/stable/API/optimization_function/#Automatic-Differentiation-Construction-Choice-Recommendations\n    optf = Optimization.OptimizationFunction((x,p)->loss(x), adtype)\n\n    optprob = Optimization.OptimizationProblem(optf, ps)\n    res = Optimization.solve(optprob, NewtonTrustRegion(), allow_f_increases=true, callback=callback)\n\n    return res.u\nend\n\nfunction test()\n    testval = [1.0,1.0]\n    main() ≈ testval\nend\n\nend","category":"page"},{"location":"problem_definition/#Problem-Definition","page":"Problem Definition","title":"Problem Definition","text":"","category":"section"},{"location":"problem_definition/#Problem-format","page":"Problem Definition","title":"Problem format","text":"","category":"section"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"Before attempting to solve a problem described by partial differential equation(s) (PDE(s)), it is necessary to express the equation(s) in a form that can be understood and processed by the solver.","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"Let us first define 1D discretization grids, for n in mathbbN:","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"a = x_1  cdots  x_n = b quad text and  quad t_0  cdots  t_end  ","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"The number of points n in the spatial discretization should be chosen based on the desired level of accuracy and the complexity of the solution.","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"We then need to consider the following system of quasilinear partial differential equations:","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"c(xtuu_x)u_t = x^-m(x^m f(xtuu_x))_x + s(xtuu_x)","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"where m denotes the symmetry of the problem (m=0, m=1 or m=2 denoting cartesian, polar cylindrical and polar spherical coordinates respectively), while the functions c(xtuu_x), f(xtuu_x) and s(xtuu_x) represent the capacity term, the flux term and the source term respectively.\nThe capacity term c(xtuu_x) must be represented as a diagonal matrix (see SkeelBerzins.mass_matrix), this means that the relationship between the partial derivatives with respect to time is limited to being multiplied by a diagonal matrix c(xtuu_x).","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"Similarly, the boundary conditions associated to the PDE(s) must conform to a specific format, which is outlined as follows:","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"p^i(xtu) + q^i(xt)f^i(xtuu_x) = 0 quad textfor  x=a text or  x=b","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"with i=1cdotsnpde (number of PDEs).","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"warning: Warning\nThe reference [1] states that if m0 then we require a geq 0 for the method to work properly.","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"The package utilizes the spatial discretization method outlined in reference [1], which results in a second-order accurate method in space.","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"Please refer to the example provided below and the section on solvers to understand how to implement the problem in the required format.","category":"page"},{"location":"problem_definition/#Example","page":"Problem Definition","title":"Example","text":"","category":"section"},{"location":"problem_definition/#Linear-Diffusion-for-m0-with-homogeneous-Neumann-boundary-conditions","page":"Problem Definition","title":"Linear Diffusion for m=0 with homogeneous Neumann boundary conditions","text":"","category":"section"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"We rewrite a linear diffusion problem in cartesian coordinates, with homogeneous Neumann boundary conditions, to conform to the format outlined above.","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"We have for x in ab, t in t_0t_end","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"u_t(xt) = u_xx(xt) \nfracdudx(at) = fracdudx(bt) = 0 \nu(xt_0) = u_0(x)","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"In the format required by the solver, it gives:","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"m = 0 quad  \nc(xtuu_x) = 1 quad  \nf(xtuu_x) = u_x quad  \ns(xtuu_x) = 0 quad  \np(xtu) = 0 quad text for  x=a text and  x=b quad  \nq(xt) = 1 quad text for  x=a text and  x=b  ","category":"page"},{"location":"example101/#Example-101:-Linear-Diffusion-equation-(DiffEq)","page":"101: Linear Diffusion equation (DiffEq)","title":"Example 101: Linear Diffusion equation (DiffEq)","text":"","category":"section"},{"location":"example101/","page":"101: Linear Diffusion equation (DiffEq)","title":"101: Linear Diffusion equation (DiffEq)","text":"Solve the following linear diffusion equation:","category":"page"},{"location":"example101/","page":"101: Linear Diffusion equation (DiffEq)","title":"101: Linear Diffusion equation (DiffEq)","text":"u_t  = u_xx","category":"page"},{"location":"example101/","page":"101: Linear Diffusion equation (DiffEq)","title":"101: Linear Diffusion equation (DiffEq)","text":"for x in Omega=(01) with homogeneous Neumann boundary conditions using the ODE solvers of the DifferentialEquations.jl package.","category":"page"},{"location":"example101/","page":"101: Linear Diffusion equation (DiffEq)","title":"101: Linear Diffusion equation (DiffEq)","text":"We take for our problem the following initial condition:","category":"page"},{"location":"example101/","page":"101: Linear Diffusion equation (DiffEq)","title":"101: Linear Diffusion equation (DiffEq)","text":"u(x0) = exp(-100*(x-025)^2)","category":"page"},{"location":"example101/","page":"101: Linear Diffusion equation (DiffEq)","title":"101: Linear Diffusion equation (DiffEq)","text":"module Example101_LinearDiffusion_DiffEq\n\nusing SkeelBerzins\n\n\nfunction main()\n\n\tN_x = 21\n\t\t\n\tL = 1\n\tT = 1\n\n\tx_mesh = collect(range(0,L,length=N_x))\n\ttspan  = (0, T)\n\n\tm = 0\n\t\n\tfpeak(x)=exp(-100*(x-0.25)^2)\n\n\tfunction pdefun(x,t,u,dudx)\n\t\tc = 1\n\t\tf = dudx \n\t\ts = 0\n\t\t\n\t\treturn c,f,s\n\tend\n\n\tfunction icfun(x)\n\t\tu0 = fpeak(x)\n\t\t\n\t\treturn u0\n\tend\n\n\n\tfunction bdfun(xl,ul,xr,ur,t)\n\t\tpl = 0\n\t\tql = 1\n\t\tpr = 0\n\t\tqr = 1\n\n\t\treturn pl,ql,pr,qr\n\tend\n\n\tparams = SkeelBerzins.Params()\n\tparams.solver = :DiffEq\n\n\tpb = pdepe(m,pdefun,icfun,bdfun,x_mesh,tspan ; params=params)\n\tproblem   = DifferentialEquations.ODEProblem(pb)\n\tsol = DifferentialEquations.solve(problem,Tsit5())\n\t\n\n\treturn sum(sol.u[end])\nend\n\nfunction test()\n    testval = 3.7210048739504296\n    main() ≈ testval\nend\n\n\nend","category":"page"},{"location":"example110/#Example-110:-System-of-Reaction-Diffusion-equations","page":"110: System of Reaction-Diffusion equations","title":"Example 110: System of Reaction-Diffusion equations","text":"","category":"section"},{"location":"example110/","page":"110: System of Reaction-Diffusion equations","title":"110: System of Reaction-Diffusion equations","text":"Solve the following system of PDEs:","category":"page"},{"location":"example110/","page":"110: System of Reaction-Diffusion equations","title":"110: System of Reaction-Diffusion equations","text":"partial_t u_1 = 05 partial^2_x u_1 - u_1 + u_2 = 0 \npartial_t u_2 = 01 partial^2_x u_2 + u_1 - u_2 = 0 \nu_1(0t) = 1 \npartial_x u_1(1t) = 0 \npartial_x u_2(0t) = 0 \nu_2(0t) = 0","category":"page"},{"location":"example110/","page":"110: System of Reaction-Diffusion equations","title":"110: System of Reaction-Diffusion equations","text":"for x in Omega=(010) using the implicit Euler method (internal method).","category":"page"},{"location":"example110/","page":"110: System of Reaction-Diffusion equations","title":"110: System of Reaction-Diffusion equations","text":"We take for our problem the following initial condition:","category":"page"},{"location":"example110/","page":"110: System of Reaction-Diffusion equations","title":"110: System of Reaction-Diffusion equations","text":"u_1(x0) = 0 \nu_2(x0) = 0","category":"page"},{"location":"example110/","page":"110: System of Reaction-Diffusion equations","title":"110: System of Reaction-Diffusion equations","text":"module Example110_SystemReactionDiffusion\n\nusing SkeelBerzins\n\nfunction main()\n\n\tN_x = 21\n\t\t\n\tL = 1\n\tT = 10\n\n\tx_mesh = collect(range(0,L,length=N_x))\n\ttspan  = (0, T)\n\n\tm = 0\n\n\tfunction pdefun_test(x,t,u,dudx)\n\t\tc = SVector(1,1)\n\t\tf = SVector(0.5,0.1) .* dudx\n\t\ty = u[1] - u[2]\n\t\ts = SVector(-y, y)\n\t\t\n\t\treturn c,f,s\n\tend\n\n\tfunction icfun_test(x)\n\t\tu0 = SVector(0.0, 0.0)\n\t\t\n\t\treturn u0\n\tend\n\n\n\tfunction bdfun_test(xl,ul,xr,ur,t)\n\t\tpl = SVector(ul[1]-1.0, 0)\n\t\tql = SVector(0, 1)\n\t\tpr = SVector(0, ur[2])\n\t\tqr = SVector(1, 0)\n\n\t\treturn pl,ql,pr,qr\n\tend\n\n\tparams = SkeelBerzins.Params()\n\tparams.tstep = 1e-2\n\n\tsol = pdepe(m,pdefun_test,icfun_test,bdfun_test,x_mesh,tspan ; params=params)\n\n\treturn sum(sol.u[end])\nend\n\nfunction test()\n    testval=29.034702247833415\n    main() ≈ testval\nend\n\nend","category":"page"},{"location":"example111/#Example-111:-Linear-Diffusion-equation-in-spherical-coordinates-(DiffEq)","page":"111: Linear Diffusion equation in spherical coordinates (DiffEq)","title":"Example 111: Linear Diffusion equation in spherical coordinates (DiffEq)","text":"","category":"section"},{"location":"example111/","page":"111: Linear Diffusion equation in spherical coordinates (DiffEq)","title":"111: Linear Diffusion equation in spherical coordinates (DiffEq)","text":"Solve the following problem:","category":"page"},{"location":"example111/","page":"111: Linear Diffusion equation in spherical coordinates (DiffEq)","title":"111: Linear Diffusion equation in spherical coordinates (DiffEq)","text":"u_t = frac1x^2(x^2 u_x)_x","category":"page"},{"location":"example111/","page":"111: Linear Diffusion equation in spherical coordinates (DiffEq)","title":"111: Linear Diffusion equation in spherical coordinates (DiffEq)","text":"for x in Omega=(01) with the imposed symmetry condition in x=0 (since use of spherical coordinates) and Dirichlet condition in x=1 using the DAE solvers of the DifferentialEquations.jl package.","category":"page"},{"location":"example111/","page":"111: Linear Diffusion equation in spherical coordinates (DiffEq)","title":"111: Linear Diffusion equation in spherical coordinates (DiffEq)","text":"We take for our problem the following initial condition:","category":"page"},{"location":"example111/","page":"111: Linear Diffusion equation in spherical coordinates (DiffEq)","title":"111: Linear Diffusion equation in spherical coordinates (DiffEq)","text":"u(x0) = x^2","category":"page"},{"location":"example111/","page":"111: Linear Diffusion equation in spherical coordinates (DiffEq)","title":"111: Linear Diffusion equation in spherical coordinates (DiffEq)","text":"module Example111_LinearDiffusionSpherical_DiffEq\n\nusing SkeelBerzins\nusing LinearAlgebra\n\nfunction main()\n\n    Nx = 21\n    \n    L = 1\n    T = 0.8\n    \n    x_mesh = collect(range(0, L, length=Nx))\n    tspan  = (0.0, T)\n    \n    m = 2\n\n    function pdefun(x,t,u,dudx)\n        c = 1\n        f = dudx\n        s = 0\n        \n        return c,f,s\n    end\n\n    function icfun(x)\n        u0 = x^2\n        \n        return u0\n    end\n\n    function bdfun(xl,ul,xr,ur,t)\n        pl = 0 # ignored by solver since m=1\n        ql = 0 # ignored by solver since m=1\n        pr = ur-(1+6*t)\n        qr = 0\n    \n        return pl,ql,pr,qr\n    end\n\n    params = SkeelBerzins.Params()\n    params.solver = :DiffEq\n\n    pb      = pdepe(m,pdefun,icfun,bdfun,x_mesh,tspan ; params=params)\n    problem = DifferentialEquations.ODEProblem(pb)\n    sol     = DifferentialEquations.solve(problem,Rosenbrock23())\n\n    exact(x,t) = x^2 + 6*t\n\n    return norm(sol.u[end] - exact.(x_mesh,T)) < 1.0e-14\nend\n\n\nfunction test()\n    main()\nend\n\nend","category":"page"},{"location":"example104/#Example-104:-Nonlinear-Diffusion-equation","page":"104: Nonlinear Diffusion equation","title":"Example 104: Nonlinear Diffusion equation","text":"","category":"section"},{"location":"example104/","page":"104: Nonlinear Diffusion equation","title":"104: Nonlinear Diffusion equation","text":"Solve the following nonlinear diffusion equation:","category":"page"},{"location":"example104/","page":"104: Nonlinear Diffusion equation","title":"104: Nonlinear Diffusion equation","text":"u_t  = (2uu_x)_x","category":"page"},{"location":"example104/","page":"104: Nonlinear Diffusion equation","title":"104: Nonlinear Diffusion equation","text":"for x in Omega=(-11) with homogeneous Neumann boundary conditions using the implicit Euler method (internal method).","category":"page"},{"location":"example104/","page":"104: Nonlinear Diffusion equation","title":"104: Nonlinear Diffusion equation","text":"We take for our problem the following initial condition (exact solution named Barenblatt solution):","category":"page"},{"location":"example104/","page":"104: Nonlinear Diffusion equation","title":"104: Nonlinear Diffusion equation","text":"u(x0001) = maxleft(0t^-alphaleft(1-fracalpha(m-1)x^22mt^2alpharight)^frac1m-1right)","category":"page"},{"location":"example104/","page":"104: Nonlinear Diffusion equation","title":"104: Nonlinear Diffusion equation","text":"for m=2 and alpha = left(m+1right)^-1.","category":"page"},{"location":"example104/","page":"104: Nonlinear Diffusion equation","title":"104: Nonlinear Diffusion equation","text":"module Example104_NonlinearDiffusion\n\nusing SkeelBerzins\n\nfunction main()\n\n\tNx = 21\n\n\tL = 1\n\tT = 0.01\n\n\tx_mesh = collect(range(-1,L,length=Nx))\n\ttspan  = (0.001,T)\n\n\tm = 0\n\n\tfunction barenblatt(x,t,p)\n\t\ttx=t^(-1.0/(p+1.0))\n\t\txx=x*tx\n\t\txx=xx*xx\n\t\txx=1- xx*(p-1)/(2.0*p*(p+1));\n\t\tif xx<0.0\n\t\t\txx=0.0\n\t\tend\n\t\treturn tx*xx^(1.0/(p-1.0))\n\tend\n\n\tfunction pdefun(x,t,u,dudx)\n\t\tc = 1\n\t\tf = 2*u*dudx\n\t\ts = 0\n\t\t\n\t\treturn c,f,s\n\tend\n\n\n\tfunction icfun(x)\n\t\tu0 = barenblatt(x,0.001,2)\n\t\t\n\t\treturn u0\n\tend\n\n\n\tfunction bdfun(xl,ul,xr,ur,t)\n\t\tpl = 0\n\t\tql = 1\n\t\tpr = 0\n\t\tqr = 1\n\n\t\treturn pl,ql,pr,qr\n\tend\n\n\tparams = SkeelBerzins.Params()\n\tparams.tstep = 1e-4\n\n\tsol = pdepe(m,pdefun,icfun,bdfun,x_mesh,tspan; params=params)\n\n\treturn sum(sol.u[end])\nend\n\n\nfunction test()\n    testval=46.66666666678757\n    main() ≈ testval\nend\n\nend","category":"page"},{"location":"example107/#Example-107:-Poisson-equation","page":"107: Poisson equation","title":"Example 107: Poisson equation","text":"","category":"section"},{"location":"example107/","page":"107: Poisson equation","title":"107: Poisson equation","text":"Solve the following 1D Poisson equation:","category":"page"},{"location":"example107/","page":"107: Poisson equation","title":"107: Poisson equation","text":"-u_xx = 1 \nu(0)=01 \nu(1)=01 ","category":"page"},{"location":"example107/","page":"107: Poisson equation","title":"107: Poisson equation","text":"for x in Omega=(01) with inhomogeneous Dirichlet boundary conditions using the implicit Euler method (internal method).","category":"page"},{"location":"example107/","page":"107: Poisson equation","title":"107: Poisson equation","text":"module Example107_Poisson\n\nusing SkeelBerzins\n\n\nfunction main()\n\n\tN_x = 21\n\t\t\n\tL = 1\n\tT = 1\n\n\tx_mesh = collect(range(0,L,length=N_x))\n\ttspan  = (0, T)\n\n\tm = 0\n\n\tfunction pdefun_test(x,t,u,dudx)\n\t\tc = 1\n\t\tf = dudx \n\t\ts = 1\n\t\t\n\t\treturn c,f,s\n\tend\n\n\tfunction icfun_test(x)\n\t\tu0 = 0.1\n\t\t\n\t\treturn u0\n\tend\n\n\n\tfunction bdfun_test(xl,ul,xr,ur,t)\n\t\tpl = ul - 0.1\n\t\tql = 0\n\t\tpr = ur - 0.1\n\t\tqr = 0\n\n\t\treturn pl,ql,pr,qr\n\tend\n\n\n\tparams = SkeelBerzins.Params()\n\tparams.tstep = Inf\n\tsol = pdepe(m,pdefun_test,icfun_test,bdfun_test,x_mesh,tspan ; params=params)\n\t\n\n\treturn sum(sol)\nend\n\nfunction test()\n    testval=3.7624999999999997\n    main() ≈ testval\nend\n\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Markdown\nMarkdown.parse(\"\"\"\n$(read(\"../../README.md\",String))\n\"\"\")","category":"page"},{"location":"example201/#Example-201:-Interpolation-of-Partial-Derivatives","page":"201: Interpolation of Partial Derivatives","title":"Example 201: Interpolation of Partial Derivatives","text":"","category":"section"},{"location":"example201/","page":"201: Interpolation of Partial Derivatives","title":"201: Interpolation of Partial Derivatives","text":"Solve the following problem","category":"page"},{"location":"example201/","page":"201: Interpolation of Partial Derivatives","title":"201: Interpolation of Partial Derivatives","text":"u_t = (Du_x)_x - (DfracηL)u_x","category":"page"},{"location":"example201/","page":"201: Interpolation of Partial Derivatives","title":"201: Interpolation of Partial Derivatives","text":"for x in Omega=(01) with homogeneous Dirichlet boundary conditions for x=0 and x=1 using the DAE solvers of the DifferentialEquations.jl package.","category":"page"},{"location":"example201/","page":"201: Interpolation of Partial Derivatives","title":"201: Interpolation of Partial Derivatives","text":"We take for our problem the following initial condition:","category":"page"},{"location":"example201/","page":"201: Interpolation of Partial Derivatives","title":"201: Interpolation of Partial Derivatives","text":"u(x0) = fracK*L*(1 - exp(-η*(1 - fracxL)))D*η","category":"page"},{"location":"example201/","page":"201: Interpolation of Partial Derivatives","title":"201: Interpolation of Partial Derivatives","text":"Then the function pdeval interpolates in space the obtained solution and its partial derivative.","category":"page"},{"location":"example201/","page":"201: Interpolation of Partial Derivatives","title":"201: Interpolation of Partial Derivatives","text":"module Example201_PartialDerivativeApprox\n\nusing SkeelBerzins\nusing LinearAlgebra\n\nfunction main()\n\n    n = 50\n\n    L = 1\n    D = 0.1\n    eta = 10\n    K = 1\n    Ip = 1\n\n    function pdefun(x,t,u,dudx)\n        c = 1\n        f = D*dudx\n        s = -(D*eta/L)*dudx\n\n        c,f,s\n    end\n\n    icfun(x) = (K*L/D)*(1 - exp(-eta*(1 - x/L)))/eta\n\n    function bcfun(xl,ul,xr,ur,t)\n        pl = ul\n        ql = 0\n        pr = ur\n        qr = 0\n\n        pl,ql,pr,qr\n    end\n\n    m = 0\n    xmesh = collect(range(0,1,length=n))\n    tspan = (0,1)\n\n    params=SkeelBerzins.Params()\n    params.solver = :DiffEq\n\n    pb = pdepe(m,pdefun,icfun,bcfun,xmesh,tspan ; params=params)\n    problem = DifferentialEquations.ODEProblem(pb,Rosenbrock23())\n    sol = DifferentialEquations.solve(problem,saveat=1/(n-1))\n\n    function analytical(t)     \n        It = 0\n        for n ∈ 1:40\n            m = (n*pi)^2 + 0.25*eta^2\n            It = It + ((n*pi)^2 / m)* exp(-(D/L^2)*m*t)\n        end\n        It = 2*Ip*((1 - exp(-eta))/eta)*It\n    end\n\n    \n    tmesh = collect(range(0,1,length=length(sol.t)))\n    \n    seriesI = analytical.(tmesh)\n\n    u1    = zeros(length(sol.t))\n    dudx1 = zeros(length(sol.t))\n    u2    = zeros(length(sol.t))\n    dudx2 = zeros(length(sol.t))\n    for t ∈ 1:n\n        u1[t], dudx1[t] = pdeval(pb.m,pb.xmesh,sol.u[t],0,pb)\n        u2[t], dudx2[t] = sol(0,sol.t[t],pb)\n    end\n\n    dudx1 .= (Ip*D/K) .* dudx1\n    dudx2 .= (Ip*D/K) .* dudx2\n\n    err1 = norm(seriesI[2:n] - dudx1[2:n], Inf)\n    err2 = norm(seriesI[2:n] - dudx2[2:n], Inf)\n\n    return err1, err2\nend\n\nfunction test()\n    testval = 0.0733179231620893\n    err1,err2 = main()\n    err1 ≈ err2 ≈ testval\nend\n\nend","category":"page"}]
}
