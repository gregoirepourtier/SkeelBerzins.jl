var documenterSearchIndex = {"docs":
[{"location":"module_examples/Example104_Poisson/#Example-104:-1D-Poisson-equation","page":"104:  Poisson","title":"Example 104: 1D Poisson equation","text":"","category":"section"},{"location":"module_examples/Example104_Poisson/","page":"104:  Poisson","title":"104:  Poisson","text":"Solve the following 1D Poisson equation:","category":"page"},{"location":"module_examples/Example104_Poisson/","page":"104:  Poisson","title":"104:  Poisson","text":"beginaligned\n-u_xx = 1\nu(0) = 01\nu(1) = 01\nendaligned","category":"page"},{"location":"module_examples/Example104_Poisson/","page":"104:  Poisson","title":"104:  Poisson","text":"for x in Omega=(01) with inhomogeneous Dirichlet boundary conditions using the implicit Euler method (internal method).","category":"page"},{"location":"module_examples/Example104_Poisson/","page":"104:  Poisson","title":"104:  Poisson","text":"module Example104_Poisson\n\nusing SkeelBerzins\n\nfunction main()\n    N_x = 21\n\n    L = 1\n    T = 1\n\n    x_mesh = collect(range(0, L; length=N_x))\n\n    m = 0\n\n    function pdefun(x, t, u, dudx)\n        c = 1\n        f = dudx\n        s = 1\n\n        return c, f, s\n    end\n\n    function icfun(x)\n        u0 = 0.1\n\n        return u0\n    end\n\n    function bdfun(xl, ul, xr, ur, t)\n        pl = ul - 0.1\n        ql = 0\n        pr = ur - 0.1\n        qr = 0\n\n        return pl, ql, pr, qr\n    end\n\n    sol = pdepe(m, pdefun, icfun, bdfun, x_mesh)\n\n    return sum(sol)\nend\n\nusing Test\n\nfunction runtests()\n    testval = 3.7624999999999997\n    @test main() ≈ testval\nend\n\nend","category":"page"},{"location":"module_examples/Example104_Poisson/","page":"104:  Poisson","title":"104:  Poisson","text":"","category":"page"},{"location":"module_examples/Example104_Poisson/","page":"104:  Poisson","title":"104:  Poisson","text":"This page was generated using Literate.jl.","category":"page"},{"location":"performance/#Achieve-Performance","page":"Achieve performance","title":"Achieve Performance","text":"","category":"section"},{"location":"performance/#Using-StaticArrays.jl","page":"Achieve performance","title":"Using StaticArrays.jl","text":"","category":"section"},{"location":"performance/","page":"Achieve performance","title":"Achieve performance","text":"One way to improve the performance of the package when solving system of PDEs, is to use the StaticArrays.jl package to define the PDE formulation.","category":"page"},{"location":"performance/","page":"Achieve performance","title":"Achieve performance","text":"This package allows you to use arrays that are stored on the stack rather than on the heap, which  eliminates the need for memory allocation when defining and evaluating the problem. In contrast, when using arrays to define the problem, it creates heap-allocations for every interval  where the function is evaluated.","category":"page"},{"location":"performance/#Example","page":"Achieve performance","title":"Example","text":"","category":"section"},{"location":"performance/","page":"Achieve performance","title":"Achieve performance","text":"using SkeelBerzins\n\n# Define symmetry of the problem\nm = 0\n\n# Define PDE Formulation\nfunction pdefunction(x,t,u,dudx)\n    c = SVector(1,1)\n    f = SVector(0.5,0.1) .* dudx\n    y = u[1] - u[2]\n    s = SVector(-y, y)\n\n    c,f,s\nend\n\n# Define the initial condition\nfunction icfunction(x)\n    u0 = SVector(0.0, 0.0)\n    \n    u0\nend\n\n# Define the boundary condtions\nfunction bdfunction(xl,ul,xr,ur,t)\n    pl = SVector(ul[1]-1.0, 0)\n    ql = SVector(0, 1)\n    pr = SVector(0, ur[2])\n    qr = SVector(1, 0)\n\n    pl,ql,pr,qr\nend\n\n# Define the spatial discretization\nxmesh = collect(range(0,1,length=21))\n\n# Define the time interval\ntspan = (0,10)\n\n# Define Keyword Arguments\nparams = SkeelBerzins.Params(tstep=1e-2)\n\n# Solve\nsol = pdepe(m,pdefunction,icfunction,bdfunction,xmesh,tspan ; params=params)","category":"page"},{"location":"module_examples/Example103_LinearDiffusionCylindrical/#Example-103:-Linear-Diffusion-Equation-in-Cylindrical-Coordinates","page":"103:  Linear Diffusion Cylindrical","title":"Example 103: Linear Diffusion Equation in Cylindrical Coordinates","text":"","category":"section"},{"location":"module_examples/Example103_LinearDiffusionCylindrical/","page":"103:  Linear Diffusion Cylindrical","title":"103:  Linear Diffusion Cylindrical","text":"Solve the following problem","category":"page"},{"location":"module_examples/Example103_LinearDiffusionCylindrical/","page":"103:  Linear Diffusion Cylindrical","title":"103:  Linear Diffusion Cylindrical","text":"u_t = frac1x(xu_x)_x","category":"page"},{"location":"module_examples/Example103_LinearDiffusionCylindrical/","page":"103:  Linear Diffusion Cylindrical","title":"103:  Linear Diffusion Cylindrical","text":"for x in Omega=(01) with the imposed symmetry condition in x=0 (since use of cylindrical coordinates) and Dirichlet condition in x=1.","category":"page"},{"location":"module_examples/Example103_LinearDiffusionCylindrical/","page":"103:  Linear Diffusion Cylindrical","title":"103:  Linear Diffusion Cylindrical","text":"We initialize our problem with the exact solution (Bessel function and its first zero):","category":"page"},{"location":"module_examples/Example103_LinearDiffusionCylindrical/","page":"103:  Linear Diffusion Cylindrical","title":"103:  Linear Diffusion Cylindrical","text":"u(x0) = J_0(nx)","category":"page"},{"location":"module_examples/Example103_LinearDiffusionCylindrical/","page":"103:  Linear Diffusion Cylindrical","title":"103:  Linear Diffusion Cylindrical","text":"where n = 2404825557695773.","category":"page"},{"location":"module_examples/Example103_LinearDiffusionCylindrical/","page":"103:  Linear Diffusion Cylindrical","title":"103:  Linear Diffusion Cylindrical","text":"module Example103_LinearDiffusionCylindrical\n\nusing SkeelBerzins, DifferentialEquations\nusing SpecialFunctions\n\nfunction main()\n    Nx = 21\n\n    L = 1\n    T = 1\n\n    x_mesh = collect(range(0, L; length=Nx))\n    tspan = (0, T)\n\n    m = 1\n\n    function pdefun(x, t, u, dudx)\n        c = 1\n        f = dudx\n        s = 0\n\n        return c, f, s\n    end\n\n    function icfun(x)\n        n = 2.404825557695773\n        u0 = besselj(0, n * x)\n\n        return u0\n    end\n\n    function bdfun(xl, ul, xr, ur, t)\n        n = 2.404825557695773\n        pl = 0 # ignored by solver since m=1\n        ql = 0 # ignored by solver since m=1\n        pr = ur - besselj(0, n) * exp(-n^2 * t)\n        qr = 0\n\n        return pl, ql, pr, qr\n    end\n\n    params = SkeelBerzins.Params(; solver=:DiffEq)\n\n    pb = pdepe(m, pdefun, icfun, bdfun, x_mesh, tspan; params=params)\n    problem = DifferentialEquations.ODEProblem(pb)\n    sol_diffEq = DifferentialEquations.solve(problem, Rosenbrock23())\n\n    sol_euler = pdepe(m, pdefun, icfun, bdfun, x_mesh, tspan)\n\n    return (sum(sol_diffEq.u[end]), sum(sol_euler.u[end]))\nend\n\nusing Test\n\nfunction runtests()\n    testval_diffEq = 0.038941562421188236\n    testval_euler = 0.0463188424523652\n    approx_diffEq, approx_euler = main()\n\n    @test approx_diffEq ≈ testval_diffEq && approx_euler ≈ testval_euler\nend\n\nend","category":"page"},{"location":"module_examples/Example103_LinearDiffusionCylindrical/","page":"103:  Linear Diffusion Cylindrical","title":"103:  Linear Diffusion Cylindrical","text":"","category":"page"},{"location":"module_examples/Example103_LinearDiffusionCylindrical/","page":"103:  Linear Diffusion Cylindrical","title":"103:  Linear Diffusion Cylindrical","text":"This page was generated using Literate.jl.","category":"page"},{"location":"solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Now that we have an understanding of the overall problem definition, we can explore the various  solvers that are included in the package and investigate their specific input and output parameters  in detail.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"The solvers expect the PDE problem to be described in the following way.","category":"page"},{"location":"solvers/#PDE-formulation","page":"Solvers","title":"PDE formulation","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"In order to define the PDE(s), we have to follow the format introduced in the previous section on  Problem Definition. For the purpose of this explanation, we use the function pdefunction(x,t,u,dudx) to describe the  PDE(s). The inputs of the function are self-explanatory. It will then return the capacity  c(x,t,u,dudx), the flux f(x,t,u,dudx) and the source s(x,t,u,dux) terms.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"This function will be passed as an argument to the solver.","category":"page"},{"location":"solvers/#Define-the-initial-conditions","page":"Solvers","title":"Define the initial conditions","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"To define the initial condition(s), we introduce the function icfunction(x) (once again, arbitrary  name). For problems that contain at least one parabolic equation, it will return the evaluation of  the initial condition on the spatial mesh xmesh at the initial time t_0.\nFor stationary problems it will return the evaluation of the initial value on the spatial mesh  xmesh used for the newton solver.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"This function will be passed as an argument to the solver.","category":"page"},{"location":"solvers/#Define-the-boundary-conditions","page":"Solvers","title":"Define the boundary conditions","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"To represent the boundary condition, we introduce the function bdfunction(xl,ul,xr,ur,t). The  input arguments are:","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"xl: left boundary point of the problem.\nul: estimate of the solution evaluated at the left boundary of the domain.\nxr: right boundary point of the problem.\nur: estimate of the solution evaluated at the right boundary of the domain.\nt: evaluates the boundary conditions at time t in t_0t_end.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"The function will return the boundary condition terms introduced in the problem definition section,  i.e. p(x,t,u) and q(x,t) for the left and right part of the spatial mesh.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"warning: Warning\nIf m0 and the left boundary point of the domain is a=0, then the solver ignores the  given boundary condition to enforce the symmetry condition ensuring second-order accuracy in  space near x=0.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"This function will be passed as an argument to the solver.","category":"page"},{"location":"solvers/#Obtaining-Solutions","page":"Solvers","title":"Obtaining Solutions","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"With the complete PDE formulation defined, we can now introduce the solver function pdepe.  Look pdepe.","category":"page"},{"location":"solvers/#Using-internal-method:-implicit-Euler-method","page":"Solvers","title":"Using internal method: implicit Euler method","text":"","category":"section"},{"location":"solvers/#Parabolic-equation(s)","page":"Solvers","title":"Parabolic equation(s)","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"The package contains an implementation of the implicit Euler method which can be used to solve  parabolic equation(s). The method has a first order error with respect to time.","category":"page"},{"location":"solvers/#Elliptic-Equation(s)","page":"Solvers","title":"Elliptic Equation(s)","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Only the internal method (implicit Euler method) can be used to solve stationary problems and is  written as follows:","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"M fracu^k+1-u^kDelta t = A(u^k+1)","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"with M the mass matrix, Delta t the time step used for the time discretization, A the  (non)linear operator resulting from the space discretization, u^k and u^k+1 the estimate  solutions at time t_0 + k Delta t and t_0 + (k+1) Delta t respectively.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"In Julia, positive infinity is defined as Inf. By setting Delta t = Inf, it follows that  frac1Delta t = 0 and thus we are left with the stationary problem which can solved by  using the Newton solver (see SkeelBerzins.newton).","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"It results that the solution for the stationary problem can be obtained by running one iteration of  the implicit Euler method.","category":"page"},{"location":"solvers/#Using-DifferentialEquations.jl","page":"Solvers","title":"Using DifferentialEquations.jl","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"SkeelBerzins.jl is also compatible with the  DifferentialEquations.jl package.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"It is possible to return the data from the problem in a SkeelBerzins.ProblemDefinition  structure, then to define an ODEProblem and solve it using an ODE/DAE solver from  DifferentialEquations.jl.","category":"page"},{"location":"solvers/#Examples","page":"Solvers","title":"Examples","text":"","category":"section"},{"location":"solvers/#Solve-with-internal-method:-implicit-Euler-method","page":"Solvers","title":"Solve with internal method: implicit Euler method","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"# Example of solving a linear diffusion PDE using the internal implicit Euler method.\n\nusing SkeelBerzins\n\n# Define symmetry of the problem\nm = 0\n\n# Define PDE Formulation\nfunction pdefunction(x,t,u,dudx)\n    c = 1\n    f = dudx\n    s = 0\n\n    c,f,s\nend\n\n# Define the initial condition\nicfunction(x) = exp(-100*(x-0.25)^2)\n\n# Define the boundary condtions\nfunction bdfunction(xl,ul,xr,ur,t)\n    pl = 0\n    ql = 1\n    pr = 0\n    qr = 1\n\n    pl,ql,pr,qr\nend\n\n# Define the spatial discretization\nxmesh = collect(range(0,1,length=21))\n\n# Define the time interval\ntspan = (0,1)\n\n# Solve\nsol = pdepe(m,pdefunction,icfunction,bdfunction,xmesh,tspan)","category":"page"},{"location":"solvers/#Solve-with-DifferentialEquations.jl","page":"Solvers","title":"Solve with DifferentialEquations.jl","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"# Example of solving a linear diffusion PDE using the DifferentialEquations.jl package.\n\nusing SkeelBerzins, DifferentialEquations\n\n# Define symmetry of the problem\nm = 0\n\n# Define PDE Formulation\nfunction pdefunction(x,t,u,dudx)\n    c = 1\n    f = dudx\n    s = 0\n\n    c,f,s\nend\n\n# Define the initial condition\nicfunction(x) = exp(-100*(x-0.25)^2)\n\n# Define the boundary condtions\nfunction bdfunction(xl,ul,xr,ur,t)\n    pl = 0\n    ql = 1\n    pr = 0\n    qr = 1\n\n    pl,ql,pr,qr\nend\n\n# Define the spatial discretization\nxmesh = collect(range(0,1,length=21))\n\n# Define the time interval\ntspan = (0,1)\n\n# Define Keyword Arguments\nparams = SkeelBerzins.Params(solver=:DiffEq)\n\n# Solve\nproblem_data = pdepe(m,pdefunction,icfunction,bdfunction,xmesh,tspan ; params=params)\nproblem_ode = DifferentialEquations.ODEProblem(problem_data)\nsol_ode = DifferentialEquations.solve(problem,Rosenbrock23())\nsol = reshape(sol_ode,problem_data)","category":"page"},{"location":"public_private_APIs/#Public-and-private-APIs","page":"Public and Private APIs","title":"Public and private APIs","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"We present here an index of all the methods that are present in the package. These are separated into two classes:","category":"page"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"Public API\nPrivate API","category":"page"},{"location":"public_private_APIs/#Public-API","page":"Public and Private APIs","title":"Public API","text":"","category":"section"},{"location":"public_private_APIs/#Solvers","page":"Public and Private APIs","title":"Solvers","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"pdepe","category":"page"},{"location":"public_private_APIs/#SkeelBerzins.pdepe","page":"Public and Private APIs","title":"SkeelBerzins.pdepe","text":"pdepe(m, pdefunction, icfunction, bdfunction, xmesh, tspan ; params=SkeelBerzins.Params(), kwargs...)\n\nSolve 1D elliptic and parabolic partial differential equation(s) using the spatial discretization method described in [1]. Note that to use this method, one of the PDEs must be parabolic. The time discretization is either done by the implicit Euler method (internal method) or by using a ODE/DAE solver from the DifferentialEquations.jl package. For more information on how to define the different inputs to solve a problem, look at the following sections: Problem Definition and Solvers.\n\nInput arguments:\n\nm: scalar referring to the symmetry of the problem. It can either take the value m=0, m=1 or m=2 representing cartesian, cylindrical or spherical coordinates respectively.\npdefunction: Function. Defines the formulation of the PDE(s) using capacity, flux and source terms.\nicfunction: Function. Defines the initial condition(s) of the problem to solve (if tstep!=Inf - initial condition(s) from the ODE/DAE problem, else if tstep=Inf - initial value(s) used for the newton solver).\nbdfunction: Function. Defines the boundary conditions of the problem.\nxmesh: 1D array representing the spatial mesh on which the user intends to obtain the solution.\ntspan: tuple (t_0 t_end) representing the time interval of the problem.\n\nKeyword argument:\n\nparams: defines a SkeelBerzins.Params struct containing the keyword arguments from the solvers.\nkwargs: instead of using the SkeelBerzins.Params struct, the user can pass directly fields from this particular struct to the solver.\n\nReturns a RecursiveArrayTools.DiffEqArray or a SkeelBerzins.ProblemDefinition struct, depending on the selected solver (either :euler or :DiffEq). The obtained solution includes a linear interpolation method in time and can be used to evaluate the solution at any time step within the interval (t_0t_end) (accessible using sol(t)). A spatial interpolation similar as the pdeval function is available on the solution object using the command sol(x_eval,t,pb).\n\n\n\n\n\npdepe(m, pdefunction, icfunction, bdfunction, xmesh ; params=SkeelBerzins.Params(tstep=Inf), kwargs...)\n\nSolve 1D elliptic PDE(s) using the spatial discretization method described in [1] - pdepe variant to solve stationary problems. Performs one step of the implicit Euler method.\n\nInput arguments:\n\nm: scalar referring to the symmetry of the problem. It can either take the value m=0, m=1 or m=2 representing cartesian, cylindrical or spherical coordinates respectively.\npdefunction: Function. Defines the formulation of the PDE(s) using capacity, flux and source terms (capacity term should be set to 0).\nicfunction: Function. It defines the initial value(s) used for the Newton solver.\nbdfunction: Function. Defines the boundary conditions of the problem.\nxmesh: 1D array representing the spatial mesh on which the user intends to obtain the solution.\n\nKeyword argument:\n\nparams: defines a SkeelBerzins.Params structure containing the keyword arguments from the solvers.\nkwargs: instead of using the SkeelBerzins.Params struct, the user can pass directly fields from this particular struct to the solver.\n\nReturns a 1D Array with the solution available at the points defined by the spatial discretization xmesh.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#Parameters-for-the-package","page":"Public and Private APIs","title":"Parameters for the package","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"Params","category":"page"},{"location":"public_private_APIs/#SkeelBerzins.Params","page":"Public and Private APIs","title":"SkeelBerzins.Params","text":"struct Params\n\nStructure containing all the keyword arguments for the solver pdepe.\n\nsolver::Symbol: Choice of the time discretization either use :euler for internal implicit Euler method or :DiffEq for the DifferentialEquations.jl package.\n\ntstep::Union{Float64, Vector{Float64}}: Defines a time step (either pass a Float64 or a Vector) when using the implicit Euler method. When set to tstep=Inf, it solves the stationary version of the problem.\n\nhist::Bool: Flag, returns with the solution, a list of 1d-array with the history from the newton solver.\n\nsparsity::Symbol: Choice of the type of matrix (:sparseArrays, :banded) use to store the jacobian.\n\nlinsolve::Union{Nothing, LinearSolve.SciMLLinearSolveAlgorithm}: Choice of the solver for the LSE in the newton method, see LinearSolve.jl.\n\nmaxit::Int64: Maximum number of iterations for the Newton solver.\n\ntol::Float64: Tolerance used for Newton method. Returns solution if  u_i+1 - u_i _2  tol.\n\ndata::Bool: Returns the data of the PDE problem\n\n\n\n\n\n","category":"type"},{"location":"public_private_APIs/#Compatibility-with-DifferentialEquations.jl","page":"Public and Private APIs","title":"Compatibility with DifferentialEquations.jl","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"Methods implemented in the SkeelBerzinsDiffEq.jl package extension.","category":"page"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"DifferentialEquations.ODEProblem\nBase.reshape","category":"page"},{"location":"public_private_APIs/#SciMLBase.ODEProblem","page":"Public and Private APIs","title":"SciMLBase.ODEProblem","text":"ODEProblem(problem)\n\nGenerate an ODEProblem from the ODEFunction which then can be solved by using the solve method.\n\nInput arguments:\n\nproblem: Structure of type SkeelBerzins.ProblemDefinition.\n\n\n\n\n\n","category":"type"},{"location":"public_private_APIs/#Base.reshape","page":"Public and Private APIs","title":"Base.reshape","text":"reshape(sol_ODE, problem)\n\nReshape the solution sol_ODE obtained by the DifferentialEquations.jl package to obtain the solution at time t as a 2D-Array of size (npde,Nx).\n\nIndeed since in the spatial discretization, we flattened the problem, the solution has a similar size. So by reshaping the solution, we get a solution organised by unknows.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#Interpolation-of-the-obtained-solution","page":"Public and Private APIs","title":"Interpolation of the obtained solution","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"pdeval","category":"page"},{"location":"public_private_APIs/#SkeelBerzins.pdeval","page":"Public and Private APIs","title":"SkeelBerzins.pdeval","text":"pdeval(m, xmesh, u_approx, x_eval, pb)\n\nFunction that interpolates with respect to the space component the solution obtained by the solver function pdepe.\n\nInput arguments:\n\nm: symmetry of the problem (m=0,1,2 for cartesian, cylindrical or spherical).\nxmesh: space discretization.\nu_approx: approximate solution obtained by the solver pdepe.\nx_eval: point or vector of points where to interpolate the approximate solution.\npb: structure defining the problem definition, see SkeelBerzins.ProblemDefinition.\n\nReturns a tuple (ududx) corresponding to the solution and its partial derivative with respect to the space component evaluated in x_eval.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#Private-API","page":"Public and Private APIs","title":"Private API","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"These methods should only be considered for developers or people trying to understand the inner  workings of the package.","category":"page"},{"location":"public_private_APIs/#Spatial-Discretization","page":"Public and Private APIs","title":"Spatial Discretization","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"SkeelBerzins.assemble!\nSkeelBerzins.interpolation","category":"page"},{"location":"public_private_APIs/#SkeelBerzins.assemble!","page":"Public and Private APIs","title":"SkeelBerzins.assemble!","text":"assemble!(du, u, problem, t)\n\nPerforms space discretization following the difference equations described in [1].\n\nAssemble the right-hand side f to generate an ODE/DAE problem:\n\n(M) fracdudt = f(uproblemt)\n\nwhere the input problem is defined as a SkeelBerzins.ProblemDefinition structure.\n\nThis function is specified in a way that it is compatible with the DifferentialEquations.jl package.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#SkeelBerzins.interpolation","page":"Public and Private APIs","title":"SkeelBerzins.interpolation","text":"interpolation(xl, ul, xr, ur, quadrature_point, problem)\n\nInterpolate u and fracdudx between two discretization points at some specific quadrature point. Method use for scalar PDE.\n\nInput arguments:\n\nxl: left boundary of the current interval.\nul: solution evaluated at the left boundary of the current interval.\nxr: right boundary of the current interval.\nur: solution evaluated at the right boundary of the current interval.\nquadrature_point: quadrature point chosen according to the method described in [1].\nproblem: Structure of type SkeelBerzins.ProblemDefinition.\n\n\n\n\n\ninterpolation(xl, ul, xr, ur, quadrature_point, m, singular, npde)\n\nInterpolate u and fracdudx between two discretization points at some specific quadrature point and return them as static vectors. Method use for system of PDEs.\n\nInput arguments:\n\nxl: left boundary of the current interval.\nul: solution evaluated at the left boundary of the current interval.\nxr: right boundary of the current interval.\nur: solution evaluated at the right boundary of the current interval.\nquadrature_point: quadrature point chosen according to the method described in [1].\nm: symmetry of the problem (given as a type).\nsingular: indicates whether the problem is regular or singular (given as a type).\nnpde: number of PDEs (given as a type).\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#Newton-solvers","page":"Public and Private APIs","title":"Newton solvers","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"SkeelBerzins.newton\nSkeelBerzins.newton_stat","category":"page"},{"location":"public_private_APIs/#SkeelBerzins.newton","page":"Public and Private APIs","title":"SkeelBerzins.newton","text":"newton(b, tau, timeStep, problem, mass_matrix, cache, rhs ; tol=1.0e-10, maxit=100, hist_flag=false, linSol=nothing)\n\nNewton method solving nonlinear system of equations. The Jacobi matrix used for the iteration rule is computed with the help of the SparseDiffTools.jl package.\n\nInput arguments:\n\nb: right-hand side of the system to solve.\ntau: constant time step used for the time discretization.\ntimeStep: current time step of tspan.\nproblem: Structure of type SkeelBerzins.ProblemDefinition.\nmass_matrix: mass matrix of the problem, see [SkeelBerzins.mass_matrix][@ref].\ncache: SparseDiffTools.ForwardColorCache. To avoid allocating the cache in each iteration of the newton solver when computing the jacobian.\nrhs: preallocated vector to avoid creating allocations.\n\nKeyword arguments:\n\ntol: tolerance or stoppping criteria (by default to 1.0e-10).\nmaxit: maximum number of iterations (by default to 100).\nhist_flag: flag to save the history and returns it (by default to false).\nlinSol: choice of the solver for the LSE, see LinearSolve.jl (by default nothing).\n\nReturns the solution of the nonlinear system of equations and if hist_flag=true, the history of the solver.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#SkeelBerzins.newton_stat","page":"Public and Private APIs","title":"SkeelBerzins.newton_stat","text":"newton_stat(b, tau, timeStep, problem, cache, rhs ; tol=1.0e-10, maxit=100, hist_flag=false, linSol=nothing)\n\nNewton method solving nonlinear system of equations (variant of newton for stationary problems).\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#Problem-definition","page":"Public and Private APIs","title":"Problem definition","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"SkeelBerzins.ProblemDefinition\nSkeelBerzins.problem_init\nSkeelBerzins.get_sparsity_pattern\nSkeelBerzins.get_quad_points_weights","category":"page"},{"location":"public_private_APIs/#SkeelBerzins.ProblemDefinition","page":"Public and Private APIs","title":"SkeelBerzins.ProblemDefinition","text":"struct ProblemDefinition{T1, T2, T3, Tv<:(AbstractVector), Ti<:Integer, Tm<:Number, elTv<:Number, pdeFunction<:Function, icFunction<:Function, bdFunction<:Function}\n\nStructure storing the problem definition.\n\nnpde::Integer: Number of unknowns\n\nNx::Integer: Number of discretization points\n\nxmesh::AbstractVector: Grid of the problem\n\ntspan::Tuple{Tm, Tm} where Tm<:Number: Time interval\n\nsingular::Bool: Flag to know if the problem is singular or not\n\nm::Integer: Symmetry of the problem\n\njac::Union{BandedMatrices.BandedMatrix{elTv, Matrix{elTv}, Base.OneTo{Ti}}, SparseArrays.SparseMatrixCSC{elTv, Ti}} where {Ti<:Integer, elTv<:Number}: Jacobi matrix\n\ninival::AbstractVector: Evaluation of the initial condition\n\nξ::AbstractVector: Interpolation points from the paper\n\nζ::AbstractVector\npdefunction::Function: Function defining the coefficients of the PDE\n\nicfunction::Function: Function defining the initial condition\n\nbdfunction::Function: Function defining the boundary conditions\n\ninterpolant::AbstractVector: Preallocated vectors for interpolation in assemble! function when solving system of PDEs\n\nd_interpolant::AbstractVector\n\n\n\n\n\n","category":"type"},{"location":"public_private_APIs/#SkeelBerzins.problem_init","page":"Public and Private APIs","title":"SkeelBerzins.problem_init","text":"problem_init(m, xmesh, tspan, pdefun, icfun, bdfun, params)\n\nFunction initializing the problem.\n\nInput arguments: similar as pdepe.\n\nReturns the size of the space discretization Nx, the number of PDEs npde, the initial value inival, some data types elTv and Ti, and the struct containing the problem definition pb.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#SkeelBerzins.get_sparsity_pattern","page":"Public and Private APIs","title":"SkeelBerzins.get_sparsity_pattern","text":"get_sparsity_pattern(sparsity, Nx, npde, elTv)\n\nFunction that provides the sparsity pattern in a SparseMatrixCSC.\n\n\n\n\n\nget_sparsity_pattern(sparsity, Nx, npde, elTv)\n\nFunction that provides the sparsity pattern in a BandedMatrix.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#SkeelBerzins.get_quad_points_weights","page":"Public and Private APIs","title":"SkeelBerzins.get_quad_points_weights","text":"get_quad_points_weights(m, alpha, beta, gamma, singular)\n\nCalculate the quadrature points and weights for the one-point Gauss quadrature based on the problem's specific symmetry, as described in the paper [1].\n\nInput arguments:\n\nm: scalar representing the symmetry of the problem.\nalpha: 1D array containing the left boundaries of the subintervals.\nbeta: 1D array containing the right boundaries of the subintervals.\ngamma: 1D array containing the middle points of the subintervals.\nsingular: boolean indicating whether the problem is singular or not.\n\nReturns the quadrature points xi and the weights zeta.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#Implicit-Euler-method","page":"Public and Private APIs","title":"Implicit Euler method","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"SkeelBerzins.implicitEuler!\nSkeelBerzins.implicitEuler_stat!\nSkeelBerzins.mass_matrix","category":"page"},{"location":"public_private_APIs/#SkeelBerzins.implicitEuler!","page":"Public and Private APIs","title":"SkeelBerzins.implicitEuler!","text":"implicitEuler!(y,u,problem,tau,mass_matrix,timeStep)\n\nAssemble the system for the implicit Euler method.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#SkeelBerzins.implicitEuler_stat!","page":"Public and Private APIs","title":"SkeelBerzins.implicitEuler_stat!","text":"implicitEuler_stat!(y,u,problem,tau,timeStep)\n\nAssemble the system for the implicit Euler method (variant method for stationary problems).\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#SkeelBerzins.mass_matrix","page":"Public and Private APIs","title":"SkeelBerzins.mass_matrix","text":"mass_matrix(problem)\n\nAssemble the diagonal mass matrix M of the system of differential equations when solving a problem with at least one parabolic PDE. The coefficients from M either take the value 0 or 1 since it is scaled in the difference equations in the right-hand side.\n\nThe entries of the matrix are set to 0 when the corresponding equation of the system is elliptic or the boundary condition is pure Dirichlet leading to solve a Differential-Algebraic system of Equations. In the case where the mass matrix is identity, we solve a system of ODEs.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#Post-processing","page":"Public and Private APIs","title":"Post-processing","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"SkeelBerzins.interpolate_sol_time\nSkeelBerzins.interpolate_sol_space","category":"page"},{"location":"public_private_APIs/#SkeelBerzins.interpolate_sol_time","page":"Public and Private APIs","title":"SkeelBerzins.interpolate_sol_time","text":"interpolate_sol_time(u_approx,t)\n\nLinear interpolatation of the solution with respect to the time component.\n\nInput arguments:\n\nu_approx: approximate solution obtained by the solver pdepe.\nt: time t in t_0t_end.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#SkeelBerzins.interpolate_sol_space","page":"Public and Private APIs","title":"SkeelBerzins.interpolate_sol_space","text":"interpolate_sol_space(u_approx, x_eval, pb, times ; val=true, deriv=true)\n\nSimilar as pdeval, i.e. interpolate the solution and its derivative with respect to the space component.\n\nInput arguments:\n\nu_approx: approximate solution obtained by the solver pdepe.\nx_eval: point or vector of points where to interpolate the approximate solution.\ntimes: point or vector of points which denotes the time step of the solution.\npb: structure defining the problem definition, see SkeelBerzins.ProblemDefinition.\n\nKeyword arguments:\n\nval: flag to return the evaluation of the solution at the x_eval position.\nderiv: flag to return the derivative with respect to the space component  of the solution at the x_eval position.\n\nReturns a tuple (ududx) corresponding to the solution and its partial derivative with respect to the space component evaluated in x_eval at time times.\n\n\n\n\n\n","category":"function"},{"location":"public_private_APIs/#Compatibility-with-DifferentialEquations.jl-2","page":"Public and Private APIs","title":"Compatibility with DifferentialEquations.jl","text":"","category":"section"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"The ODEFunction constructor is implicitely defined in the ODEProblem and so doesn't need to be  considered by the user to solve the problem with the DifferentialEquations.jl  package.","category":"page"},{"location":"public_private_APIs/","page":"Public and Private APIs","title":"Public and Private APIs","text":"DifferentialEquations.ODEFunction","category":"page"},{"location":"public_private_APIs/#SciMLBase.ODEFunction","page":"Public and Private APIs","title":"SciMLBase.ODEFunction","text":"ODEFunction(problem)\n\nGenerate an ODEFunction from the spatial discretization derived in the SkeelBerzins.assemble! function. It is expressed as a mass matrix ODE if the mass matrix is different from the identity matrix or as a simple system of ODEs otherwise and defines the problem with respect to the sparsity pattern.\n\nInput argument:\n\nproblem: Structure of type SkeelBerzins.ProblemDefinition.\n\n\n\n\n\n","category":"type"},{"location":"module_examples/Example105_StationaryNonLinearDiffusion/#Example-105:-Stationary-Nonlinear-Diffusion-equation","page":"105:  Stationary Non Linear Diffusion","title":"Example 105: Stationary Nonlinear Diffusion equation","text":"","category":"section"},{"location":"module_examples/Example105_StationaryNonLinearDiffusion/","page":"105:  Stationary Non Linear Diffusion","title":"105:  Stationary Non Linear Diffusion","text":"Solve the following nonlinear diffusion equation:","category":"page"},{"location":"module_examples/Example105_StationaryNonLinearDiffusion/","page":"105:  Stationary Non Linear Diffusion","title":"105:  Stationary Non Linear Diffusion","text":"beginaligned\n-(2uu_x)_x = 1 \nu(0) = 01 \nu(1) = 01 \nendaligned","category":"page"},{"location":"module_examples/Example105_StationaryNonLinearDiffusion/","page":"105:  Stationary Non Linear Diffusion","title":"105:  Stationary Non Linear Diffusion","text":"for x in Omega=(01) with inhomogeneous Dirichlet boundary conditions using the implicit Euler method (internal method).","category":"page"},{"location":"module_examples/Example105_StationaryNonLinearDiffusion/","page":"105:  Stationary Non Linear Diffusion","title":"105:  Stationary Non Linear Diffusion","text":"module Example105_StationaryNonlinearDiffusion\n\nusing SkeelBerzins\n\nfunction main()\n    N_x = 21\n\n    L = 1\n    T = 1\n\n    x_mesh = collect(range(0, L; length=N_x))\n\n    m = 0\n\n    function pdefun(x, t, u, dudx)\n        c = 1\n        f = 2 * u * dudx\n        s = 1\n\n        return c, f, s\n    end\n\n    function icfun(x)\n        u0 = 0.1\n\n        return u0\n    end\n\n    function bdfun(xl, ul, xr, ur, t)\n        pl = ul - 0.1\n        ql = 0\n        pr = ur - 0.1\n        qr = 0\n\n        return pl, ql, pr, qr\n    end\n\n    sol = pdepe(m, pdefun, icfun, bdfun, x_mesh)\n\n    return sum(sol)\nend\n\nusing Test\n\nfunction runtests()\n    testval = 6.025575019008793\n    sol = main()\n    @test sol ≈ testval\nend\n\nend","category":"page"},{"location":"module_examples/Example105_StationaryNonLinearDiffusion/","page":"105:  Stationary Non Linear Diffusion","title":"105:  Stationary Non Linear Diffusion","text":"","category":"page"},{"location":"module_examples/Example105_StationaryNonLinearDiffusion/","page":"105:  Stationary Non Linear Diffusion","title":"105:  Stationary Non Linear Diffusion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example107_LinearDiffusionSpherical/#Example-107:-Linear-Diffusion-Problem-in-Spherical-Coordinates","page":"107:  Linear Diffusion Spherical","title":"Example 107: Linear Diffusion Problem in Spherical Coordinates","text":"","category":"section"},{"location":"module_examples/Example107_LinearDiffusionSpherical/","page":"107:  Linear Diffusion Spherical","title":"107:  Linear Diffusion Spherical","text":"Solve the following problem:","category":"page"},{"location":"module_examples/Example107_LinearDiffusionSpherical/","page":"107:  Linear Diffusion Spherical","title":"107:  Linear Diffusion Spherical","text":"u_t = frac1x^2(x^2 u_x)_x","category":"page"},{"location":"module_examples/Example107_LinearDiffusionSpherical/","page":"107:  Linear Diffusion Spherical","title":"107:  Linear Diffusion Spherical","text":"for x in Omega=(01) with the imposed symmetry condition in x=0 (since use of spherical coordinates) and Dirichlet condition in x=1.","category":"page"},{"location":"module_examples/Example107_LinearDiffusionSpherical/","page":"107:  Linear Diffusion Spherical","title":"107:  Linear Diffusion Spherical","text":"We take for our problem the following initial condition:","category":"page"},{"location":"module_examples/Example107_LinearDiffusionSpherical/","page":"107:  Linear Diffusion Spherical","title":"107:  Linear Diffusion Spherical","text":"u(x0) = x^2","category":"page"},{"location":"module_examples/Example107_LinearDiffusionSpherical/","page":"107:  Linear Diffusion Spherical","title":"107:  Linear Diffusion Spherical","text":"module Example107_LinearDiffusionSpherical\n\nusing SkeelBerzins, DifferentialEquations\nusing LinearAlgebra\n\nfunction main()\n    Nx = 21\n\n    L = 1\n    T = 0.8\n\n    x_mesh = collect(range(0, L; length=Nx))\n    tspan = (0.0, T)\n\n    m = 2\n\n    function pdefun(x, t, u, dudx)\n        c = 1\n        f = dudx\n        s = 0\n\n        return c, f, s\n    end\n\n    function icfun(x)\n        u0 = x^2\n\n        return u0\n    end\n\n    function bdfun(xl, ul, xr, ur, t)\n        pl = 0 # ignored by solver since m=1\n        ql = 0 # ignored by solver since m=1\n        pr = ur - (1 + 6 * t)\n        qr = 0\n\n        return pl, ql, pr, qr\n    end\n\n    params = SkeelBerzins.Params(; solver=:DiffEq)\n\n    pb = pdepe(m, pdefun, icfun, bdfun, x_mesh, tspan; params=params)\n    problem = DifferentialEquations.ODEProblem(pb)\n    sol_diffEq = DifferentialEquations.solve(problem, Rosenbrock23())\n\n    sol_euler = pdepe(m, pdefun, icfun, bdfun, x_mesh, tspan)\n\n    exact(x, t) = x^2 + 6 * t\n\n    return norm(sol_diffEq.u[end] - exact.(x_mesh, T)) < 1.0e-14 &&\n           norm(sol_euler.u[end] - exact.(x_mesh, T)) < 1.0e-2\nend\n\nusing Test\n\nfunction runtests()\n    @test main()\nend\n\nend","category":"page"},{"location":"module_examples/Example107_LinearDiffusionSpherical/","page":"107:  Linear Diffusion Spherical","title":"107:  Linear Diffusion Spherical","text":"","category":"page"},{"location":"module_examples/Example107_LinearDiffusionSpherical/","page":"107:  Linear Diffusion Spherical","title":"107:  Linear Diffusion Spherical","text":"This page was generated using Literate.jl.","category":"page"},{"location":"problem_definition/#Problem-Definition","page":"Problem Definition","title":"Problem Definition","text":"","category":"section"},{"location":"problem_definition/#Problem-format","page":"Problem Definition","title":"Problem format","text":"","category":"section"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"Before attempting to solve a problem described by partial differential equation(s), it is necessary  to express the equation(s) in a form that can be understood and processed by the solver.","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"Let us first define 1D discretization grids, for n in mathbbN:","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"a = x_1  cdots  x_n = b quad text and  quad t_0  cdots  t_end  ","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"The number of points n in the spatial discretization should be chosen based on the desired level  of accuracy and the complexity of the solution.","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"We then need to consider the following system of quasilinear partial differential equations:","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"c(xtuu_x)u_t = x^-m(x^m f(xtuu_x))_x + s(xtuu_x)","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"where m denotes the symmetry of the problem (m=0, m=1 or m=2 denoting cartesian,  polar cylindrical and polar spherical coordinates respectively), while the functions  c(xtuu_x), f(xtuu_x) and s(xtuu_x) represent the capacity term, the flux term  and the source term respectively.\nThe capacity term c(xtuu_x) must be represented as a diagonal matrix (see  SkeelBerzins.mass_matrix), this means that the relationship between the partial  derivatives with respect to time is limited to being multiplied by a diagonal matrix  c(xtuu_x).","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"Similarly, the boundary conditions associated to the PDE(s) must conform to a specific format,  which is outlined as follows:","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"p^i(xtu) + q^i(xt)f^i(xtuu_x) = 0 quad textfor  x=a text or  x=b","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"with i=1cdotsnpde (number of PDEs).","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"warning: Warning\nThe reference [1] states that if m0 then we require  a geq 0 for the method to work properly.","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"The package is based on the spatial discretization method outlined in reference  [1], which results in a second-order accurate method in space.","category":"page"},{"location":"problem_definition/","page":"Problem Definition","title":"Problem Definition","text":"Please refer to the section on solvers to understand how to implement the problem in the required  format.","category":"page"},{"location":"module_examples/Example102_NonlinearDiffusion/#Example-102:-Nonlinear-Diffusion-1D","page":"102:  Nonlinear Diffusion","title":"Example 102: Nonlinear Diffusion 1D","text":"","category":"section"},{"location":"module_examples/Example102_NonlinearDiffusion/","page":"102:  Nonlinear Diffusion","title":"102:  Nonlinear Diffusion","text":"Solve the following nonlinear diffusion equation","category":"page"},{"location":"module_examples/Example102_NonlinearDiffusion/","page":"102:  Nonlinear Diffusion","title":"102:  Nonlinear Diffusion","text":"u_t  = (2uu_x)_x","category":"page"},{"location":"module_examples/Example102_NonlinearDiffusion/","page":"102:  Nonlinear Diffusion","title":"102:  Nonlinear Diffusion","text":"for x in Omega=(-11) with homogeneous Neumann boundary conditions.","category":"page"},{"location":"module_examples/Example102_NonlinearDiffusion/","page":"102:  Nonlinear Diffusion","title":"102:  Nonlinear Diffusion","text":"We take for our problem the following initial condition (exact solution named Barenblatt solution):","category":"page"},{"location":"module_examples/Example102_NonlinearDiffusion/","page":"102:  Nonlinear Diffusion","title":"102:  Nonlinear Diffusion","text":"u(x0001) = maxleft(0t^-alphaleft(1-fracalpha(m-1)x^22mt^2alpharight)^frac1m-1right)","category":"page"},{"location":"module_examples/Example102_NonlinearDiffusion/","page":"102:  Nonlinear Diffusion","title":"102:  Nonlinear Diffusion","text":"for m=2 and alpha = left(m+1right)^-1.","category":"page"},{"location":"module_examples/Example102_NonlinearDiffusion/","page":"102:  Nonlinear Diffusion","title":"102:  Nonlinear Diffusion","text":"module Example102_NonlinearDiffusion\n\nusing SkeelBerzins, DifferentialEquations\n\nfunction main()\n    Nx = 21\n\n    L = 1\n    T = 0.01\n\n    x_mesh = collect(range(-1, L; length=Nx))\n    tspan = (0.001, T)\n\n    m = 0\n\n    function barenblatt(x, t, p)\n        tx = t^(-1.0 / (p + 1.0))\n        xx = x * tx\n        xx = xx * xx\n        xx = 1 - xx * (p - 1) / (2.0 * p * (p + 1))\n        if xx < 0.0\n            xx = 0.0\n        end\n        return tx * xx^(1.0 / (p - 1.0))\n    end\n\n    function pdefun(x, t, u, dudx)\n        c = 1\n        f = 2 * u * dudx\n        s = 0\n\n        return c, f, s\n    end\n\n    function icfun(x)\n        u0 = barenblatt(x, 0.001, 2)\n\n        return u0\n    end\n\n    function bdfun(xl, ul, xr, ur, t)\n        pl = 0\n        ql = 1\n        pr = 0\n        qr = 1\n\n        return pl, ql, pr, qr\n    end\n\n    params_diffEq = SkeelBerzins.Params(; solver=:DiffEq)\n\n    pb = pdepe(m, pdefun, icfun, bdfun, x_mesh, tspan; params=params_diffEq)\n    problem = DifferentialEquations.ODEProblem(pb)\n    sol_diffEq = DifferentialEquations.solve(problem, Tsit5())\n\n    params_euler = SkeelBerzins.Params(; tstep=1e-4)\n\n    sol_euler = pdepe(m, pdefun, icfun, bdfun, x_mesh, tspan; params=params_euler)\n\n    return (sum(sol_diffEq.u[end]), sum(sol_euler.u[end]))\nend\n\nusing Test\n\nfunction runtests()\n    testval_diffEq = 46.66666666671536\n    testval_euler = 46.66666666678757\n    approx_diffEq, approx_euler = main()\n\n    @test approx_diffEq ≈ testval_diffEq && approx_euler ≈ testval_euler\nend\n\nend","category":"page"},{"location":"module_examples/Example102_NonlinearDiffusion/","page":"102:  Nonlinear Diffusion","title":"102:  Nonlinear Diffusion","text":"","category":"page"},{"location":"module_examples/Example102_NonlinearDiffusion/","page":"102:  Nonlinear Diffusion","title":"102:  Nonlinear Diffusion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example201_PartialDerivativeApprox/#Example-201:-Interpolation-of-Partial-Derivatives","page":"201:  Partial Derivative Approx","title":"Example 201: Interpolation of Partial Derivatives","text":"","category":"section"},{"location":"module_examples/Example201_PartialDerivativeApprox/","page":"201:  Partial Derivative Approx","title":"201:  Partial Derivative Approx","text":"Solve the following problem:","category":"page"},{"location":"module_examples/Example201_PartialDerivativeApprox/","page":"201:  Partial Derivative Approx","title":"201:  Partial Derivative Approx","text":"u_t = (Du_x)_x - (DfracηL)u_x","category":"page"},{"location":"module_examples/Example201_PartialDerivativeApprox/","page":"201:  Partial Derivative Approx","title":"201:  Partial Derivative Approx","text":"for x in Omega=(01) with homogeneous Dirichlet boundary conditions for x=0 and x=1 using the DAE solvers of the DifferentialEquations.jl package.","category":"page"},{"location":"module_examples/Example201_PartialDerivativeApprox/","page":"201:  Partial Derivative Approx","title":"201:  Partial Derivative Approx","text":"We take for our problem the following initial condition:","category":"page"},{"location":"module_examples/Example201_PartialDerivativeApprox/","page":"201:  Partial Derivative Approx","title":"201:  Partial Derivative Approx","text":"u(x0) = (KfracLD)frac(1 - exp(-η*(1 - fracxL)))η","category":"page"},{"location":"module_examples/Example201_PartialDerivativeApprox/","page":"201:  Partial Derivative Approx","title":"201:  Partial Derivative Approx","text":"Then the function pdeval interpolates in space the obtained solution and its partial derivative.","category":"page"},{"location":"module_examples/Example201_PartialDerivativeApprox/","page":"201:  Partial Derivative Approx","title":"201:  Partial Derivative Approx","text":"module Example201_PartialDerivativeApprox\n\nusing SkeelBerzins, DifferentialEquations\nusing LinearAlgebra\n\nfunction main()\n    n = 50\n\n    L = 1\n    D = 0.1\n    eta = 10\n    K = 1\n    Ip = 1\n\n    function pdefun(x, t, u, dudx)\n        c = 1\n        f = D * dudx\n        s = -(D * eta / L) * dudx\n\n        c, f, s\n    end\n\n    icfun(x) = (K * L / D) * (1 - exp(-eta * (1 - x / L))) / eta\n\n    function bcfun(xl, ul, xr, ur, t)\n        pl = ul\n        ql = 0\n        pr = ur\n        qr = 0\n\n        pl, ql, pr, qr\n    end\n\n    m = 0\n    xmesh = collect(range(0, 1; length=n))\n    tspan = (0, 1)\n\n    params = SkeelBerzins.Params(; solver=:DiffEq)\n\n    pb = pdepe(m, pdefun, icfun, bcfun, xmesh, tspan; params=params)\n    problem = DifferentialEquations.ODEProblem(pb)\n    sol_diffEq = DifferentialEquations.solve(problem, Rosenbrock23(); saveat=1 / (n - 1))\n\n    sol_euler, pb_data_euler = pdepe(m, pdefun, icfun, bcfun, xmesh, tspan; data=true, tstep=1 / (n - 1))\n\n    @assert sol_euler.t==sol_diffEq.t \"error: different time steps\"\n\n    function analytical(t)\n        It = 0\n        for n ∈ 1:40\n            m = (n * pi)^2 + 0.25 * eta^2\n            It = It + ((n * pi)^2 / m) * exp(-(D / L^2) * m * t)\n        end\n        It = 2 * Ip * ((1 - exp(-eta)) / eta) * It\n    end\n\n    tmesh = collect(range(0, 1; length=length(sol_diffEq.t)))\n\n    seriesI = analytical.(tmesh)\n\n    u1, dudx1 = (zeros(length(sol_diffEq.t)), zeros(length(sol_diffEq.t)))\n    u2, dudx2 = (copy(u1), copy(dudx1))\n    u3, dudx3 = (copy(u1), copy(dudx1))\n    u4, dudx4 = (copy(u1), copy(dudx1))\n    for t ∈ 1:n\n        u1[t], dudx1[t] = pdeval(pb.m, pb.xmesh, sol_diffEq.u[t], 0, pb)\n        u2[t], dudx2[t] = sol_diffEq(0, sol_diffEq.t[t], pb)\n        u3[t], dudx3[t] = pdeval(pb_data_euler.m, pb_data_euler.xmesh, sol_euler.u[t], 0, pb_data_euler)\n        u4[t], dudx4[t] = sol_euler(0, sol_euler.t[t], pb_data_euler)\n    end\n\n    dudx1 .= (Ip * D / K) .* dudx1\n    dudx2 .= (Ip * D / K) .* dudx2\n    dudx3 .= (Ip * D / K) .* dudx3\n    dudx4 .= (Ip * D / K) .* dudx4\n\n    err1 = norm(seriesI[2:n] - dudx1[2:n], Inf)\n    err2 = norm(seriesI[2:n] - dudx2[2:n], Inf)\n    err3 = norm(seriesI[2:n] - dudx3[2:n], Inf)\n    err4 = norm(seriesI[2:n] - dudx4[2:n], Inf)\n\n    return err1, err2, err3, err4\nend\n\nusing Test\n\nfunction runtests()\n    testval_diffEq = 0.07193510317047391\n    testval_euler = 0.6621164947313215\n    err1, err2, err3, err4 = main()\n    @test err1 ≈ err2 ≈ testval_diffEq && err3 ≈ err4 ≈ testval_euler\nend\n\nend","category":"page"},{"location":"module_examples/Example201_PartialDerivativeApprox/","page":"201:  Partial Derivative Approx","title":"201:  Partial Derivative Approx","text":"","category":"page"},{"location":"module_examples/Example201_PartialDerivativeApprox/","page":"201:  Partial Derivative Approx","title":"201:  Partial Derivative Approx","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example301_PDEOptimSciMLSensitivity/#Example-301:-PDE-Optim-SciML-Sensitivity","page":"301: PDE Optim SciML Sensitivity","title":"Example 301: PDE Optim SciML Sensitivity","text":"","category":"section"},{"location":"module_examples/Example301_PDEOptimSciMLSensitivity/","page":"301: PDE Optim SciML Sensitivity","title":"301: PDE Optim SciML Sensitivity","text":"This example is used to show the integration of the package in the SciML ecosystem. For more details on the problem, look at the original formulation .","category":"page"},{"location":"module_examples/Example301_PDEOptimSciMLSensitivity/","page":"301: PDE Optim SciML Sensitivity","title":"301: PDE Optim SciML Sensitivity","text":"module Example301_PDEOptimSciMLSensitivity\nusing SkeelBerzins, DifferentialEquations\n\nusing DelimitedFiles\nusing Optimization, OptimizationPolyalgorithms, OptimizationOptimJL, SciMLSensitivity\n\nfunction f(p)\n\n    # Problem setup parameters:\n    m = 0\n    Lx = 10.0\n    x = 0.0:0.01:Lx\n    dx = x[2] - x[1]\n\n    # Problem Parameters\n    dt = 0.40 * dx^2    # CFL condition\n    t0, tMax = 0.0, 1000 * dt\n    tspan = (t0, tMax)\n    t = t0:dt:tMax\n\n    a0, a1 = p\n\n    function pdefun(x, t, u, dudx)\n        c = 1\n        f = a1 * dudx\n        s = 2.0 * a0 * u\n\n        c, f, s\n    end\n\n    icfun(x) = exp(-(x - 3.0)^2)\n\n    function bcfun(xl, ul, xr, ur, t)\n        pl = ul\n        ql = 0\n        pr = ur\n        qr = 0\n\n        pl, ql, pr, qr\n    end\n\n    params_pdepe = SkeelBerzins.Params(; solver=:DiffEq)\n\n    pb = pdepe(m, pdefun, icfun, bcfun, collect(x), tspan; params=params_pdepe)\n    prob = DifferentialEquations.ODEProblem(pb)\n    sol = DifferentialEquations.solve(prob, RadauIIA3(; linsolve=SparspakFactorization()); dt=dt, saveat=t)\n\n    sol\nend\n\nfunction main()\n    p = [1.0, 1.0] # True solution parameters\n    sol_exact = f(p)\n\n    # Building the Prediction Model\n    ps = [0.1, 0.2]  # Initial guess for model parameters\n    function predict(θ)\n        sol = f(θ)\n        Array(sol)\n    end\n\n    # Defining Loss function\n    function loss(θ)\n        pred = predict(θ)\n        l = predict(θ) - sol_exact\n        return sum(abs2, l), pred # Mean squared error\n    end\n\n    LOSS = []     # Loss accumulator\n    PRED = []     # prediction accumulator\n    PARS = []     # parameters accumulator\n\n    callback = function (θ, l, pred) # callback function to observe training\n        # display(l)\n        append!(PRED, [pred])\n        append!(LOSS, l)\n        append!(PARS, [θ])\n        false\n    end\n\n    adtype = Optimization.AutoForwardDiff() # see https://docs.sciml.ai/Optimization/stable/API/optimization_function/#Automatic-Differentiation-Construction-Choice-Recommendations\n    optf = Optimization.OptimizationFunction((x, p) -> loss(x), adtype)\n\n    optprob = Optimization.OptimizationProblem(optf, ps)\n    res = Optimization.solve(optprob, NewtonTrustRegion(); allow_f_increases=true, callback=callback)\n\n    return res.u\nend\n\nusing Test\n\nfunction runtests()\n    testval = [1.0, 1.0]\n    @test main() ≈ testval\nend\n\nend","category":"page"},{"location":"module_examples/Example301_PDEOptimSciMLSensitivity/","page":"301: PDE Optim SciML Sensitivity","title":"301: PDE Optim SciML Sensitivity","text":"","category":"page"},{"location":"module_examples/Example301_PDEOptimSciMLSensitivity/","page":"301: PDE Optim SciML Sensitivity","title":"301: PDE Optim SciML Sensitivity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example106_SystemReactionDiffusion/#Example-106:-System-of-Reaction-Diffusion-PDEs","page":"106:  System Reaction Diffusion","title":"Example 106: System of Reaction-Diffusion PDEs","text":"","category":"section"},{"location":"module_examples/Example106_SystemReactionDiffusion/","page":"106:  System Reaction Diffusion","title":"106:  System Reaction Diffusion","text":"Solve the following system of PDEs:","category":"page"},{"location":"module_examples/Example106_SystemReactionDiffusion/","page":"106:  System Reaction Diffusion","title":"106:  System Reaction Diffusion","text":"beginaligned\npartial_t u_1 = 05 partial^2_x u_1 - u_1 + u_2 \npartial_t u_2 = 01 partial^2_x u_2 + u_1 - u_2 \nu_1(0t) = 1 \npartial_x u_1(1t) = 0 \npartial_x u_2(0t) = 0 \nu_2(0t) = 0\nendaligned","category":"page"},{"location":"module_examples/Example106_SystemReactionDiffusion/","page":"106:  System Reaction Diffusion","title":"106:  System Reaction Diffusion","text":"for x in Omega=(010).","category":"page"},{"location":"module_examples/Example106_SystemReactionDiffusion/","page":"106:  System Reaction Diffusion","title":"106:  System Reaction Diffusion","text":"We take for our problem the following initial conditions:","category":"page"},{"location":"module_examples/Example106_SystemReactionDiffusion/","page":"106:  System Reaction Diffusion","title":"106:  System Reaction Diffusion","text":"beginaligned\nu_1(x0) = 0 \nu_2(x0) = 0\nendaligned","category":"page"},{"location":"module_examples/Example106_SystemReactionDiffusion/","page":"106:  System Reaction Diffusion","title":"106:  System Reaction Diffusion","text":"module Example106_SystemReactionDiffusion\n\nusing SkeelBerzins, DifferentialEquations\n\nfunction main()\n    N_x = 21\n\n    L = 1\n    T = 10\n\n    x_mesh = collect(range(0, L; length=N_x))\n    tspan = (0, T)\n\n    m = 0\n\n    function pdefun(x, t, u, dudx)\n        c = SVector(1, 1)\n        f = SVector(0.5, 0.1) .* dudx\n        y = u[1] - u[2]\n        s = SVector(-y, y)\n\n        return c, f, s\n    end\n\n    function icfun(x)\n        u0 = SVector(0.0, 0.0)\n\n        return u0\n    end\n\n    function bdfun(xl, ul, xr, ur, t)\n        pl = SVector(ul[1] - 1.0, 0)\n        ql = SVector(0, 1)\n        pr = SVector(0, ur[2])\n        qr = SVector(1, 0)\n\n        return pl, ql, pr, qr\n    end\n\n    params_diffEq = SkeelBerzins.Params(; solver=:DiffEq)\n\n    pb = pdepe(m, pdefun, icfun, bdfun, x_mesh, tspan; params=params_diffEq)\n    problem = DifferentialEquations.ODEProblem(pb)\n    sol_diffEq = DifferentialEquations.solve(problem, Rosenbrock23())\n    sol_reshaped_diffEq = reshape(sol_diffEq, pb)\n\n    params_euler = SkeelBerzins.Params(; tstep=1e-2)\n\n    sol_euler = pdepe(m, pdefun, icfun, bdfun, x_mesh, tspan; params=params_euler)\n\n    return (sum(sol_diffEq.u[end]), sum(sol_euler.u[end]), sol_reshaped_diffEq)\nend\n\nusing Test\n\nfunction runtests()\n    testval_diffEq = 29.035923566365785\n    testval_euler = 29.034702247833415\n\n    approx_diffEq, approx_euler, sol_reshaped = main()\n\n    @test approx_diffEq ≈ testval_diffEq && approx_euler ≈ testval_euler && size(sol_reshaped)[1] == 2\nend\n\nend","category":"page"},{"location":"module_examples/Example106_SystemReactionDiffusion/","page":"106:  System Reaction Diffusion","title":"106:  System Reaction Diffusion","text":"","category":"page"},{"location":"module_examples/Example106_SystemReactionDiffusion/","page":"106:  System Reaction Diffusion","title":"106:  System Reaction Diffusion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Markdown\nMarkdown.parse(\"\"\"\n$(read(\"../../README.md\",String))\n\"\"\")","category":"page"},{"location":"module_examples/Example101_LinearDiffusion/#Example-101:-Linear-Diffusion-1D","page":"101:  Linear Diffusion","title":"Example 101: Linear Diffusion 1D","text":"","category":"section"},{"location":"module_examples/Example101_LinearDiffusion/","page":"101:  Linear Diffusion","title":"101:  Linear Diffusion","text":"Solve the following linear diffusion equation","category":"page"},{"location":"module_examples/Example101_LinearDiffusion/","page":"101:  Linear Diffusion","title":"101:  Linear Diffusion","text":"u_t  = u_xx","category":"page"},{"location":"module_examples/Example101_LinearDiffusion/","page":"101:  Linear Diffusion","title":"101:  Linear Diffusion","text":"for x in Omega=(01) with homogeneous Neumann boundary conditions.","category":"page"},{"location":"module_examples/Example101_LinearDiffusion/","page":"101:  Linear Diffusion","title":"101:  Linear Diffusion","text":"We take for our problem the following initial condition:","category":"page"},{"location":"module_examples/Example101_LinearDiffusion/","page":"101:  Linear Diffusion","title":"101:  Linear Diffusion","text":"u(x0) = exp(-100*(x-025)^2)","category":"page"},{"location":"module_examples/Example101_LinearDiffusion/","page":"101:  Linear Diffusion","title":"101:  Linear Diffusion","text":"module Example101_LinearDiffusion\n\nusing SkeelBerzins, DifferentialEquations, DoubleFloats\n\nfunction solve_problem(m, pdefun, icfun, bdfun, xmesh, tspan, params; linsolve=nothing)\n    if params.solver == :DiffEq\n        pb = pdepe(m, pdefun, icfun, bdfun, xmesh, tspan; params=params)\n        problem = DifferentialEquations.ODEProblem(pb)\n        sol = DifferentialEquations.solve(problem, Rosenbrock23(; linsolve=linsolve))\n    else\n        sol = pdepe(m, pdefun, icfun, bdfun, xmesh, tspan; params=params)\n    end\n\n    sol\nend\n\nfunction main()\n    N_x = 21\n\n    x_mesh = collect(range(0, 1; length=N_x))\n    x_mesh_doubleFloat = collect(Double64, range(0, 1; length=N_x))\n\n    tspan = (0, 1)\n\n    m = 0\n\n    fpeak(x) = exp(-100 * (x - 0.25)^2)\n\n    function pdefun(x, t, u, dudx)\n        c = 1\n        f = dudx\n        s = 0\n\n        return c, f, s\n    end\n\n    function icfun(x)\n        u0 = fpeak(x)\n\n        return u0\n    end\n\n    function bdfun(xl, ul, xr, ur, t)\n        pl = 0\n        ql = 1\n        pr = 0\n        qr = 1\n\n        return pl, ql, pr, qr\n    end\n\n    params_DiffEq = SkeelBerzins.Params(; solver=:DiffEq, sparsity=:sparseArrays)\n\n    sol_DiffEq = solve_problem(m, pdefun, icfun, bdfun, x_mesh, tspan, params_DiffEq)\n    sol_DiffEq_doubleFloat = solve_problem(m,\n                                           pdefun,\n                                           icfun,\n                                           bdfun,\n                                           x_mesh_doubleFloat,\n                                           tspan,\n                                           params_DiffEq;\n                                           linsolve=SparspakFactorization())\n\n    tstep = collect(0:1e-3:1)\n    params_euler_vecTstep = SkeelBerzins.Params(; solver=:euler, tstep=tstep, hist=true)\n    params_euler_fixTstep = SkeelBerzins.Params(; solver=:euler, tstep=1e-3)\n\n    sol_euler_vecTstep, hist = solve_problem(m,\n                                             pdefun,\n                                             icfun,\n                                             bdfun,\n                                             x_mesh,\n                                             tspan,\n                                             params_euler_vecTstep)\n    sol_euler_fixTstep = solve_problem(m,\n                                       pdefun,\n                                       icfun,\n                                       bdfun,\n                                       x_mesh,\n                                       tspan,\n                                       params_euler_fixTstep)\n    sol_euler_doubleFloat = pdepe(m,\n                                  pdefun,\n                                  icfun,\n                                  bdfun,\n                                  x_mesh_doubleFloat,\n                                  tspan;\n                                  solver=:euler,\n                                  tstep=1e-3,\n                                  linsolve=SparspakFactorization())\n\n    if VERSION >= VersionNumber(1, 9, 0)\n        params_DiffEq_banded = SkeelBerzins.Params(; solver=:DiffEq, sparsity=:banded)\n        sol_DiffEq_banded = solve_problem(m,\n                                          pdefun,\n                                          icfun,\n                                          bdfun,\n                                          x_mesh,\n                                          tspan,\n                                          params_DiffEq_banded;\n                                          linsolve=LUFactorization())\n\n        sol_euler_banded = pdepe(m,\n                                 pdefun,\n                                 icfun,\n                                 bdfun,\n                                 x_mesh,\n                                 tspan;\n                                 solver=:euler,\n                                 sparsity=:banded,\n                                 tstep=1e-3,\n                                 linsolve=LUFactorization())\n\n        return (sum(sol_DiffEq.u[end]), sum(sol_DiffEq_banded.u[end]),\n                eltype(eltype(sol_DiffEq_doubleFloat.u)),\n                sum(sol_euler_vecTstep.u[end]), sum(sol_euler_fixTstep.u[end]),\n                sum(sol_euler_banded.u[end]), eltype(eltype(sol_euler_doubleFloat.u)))\n    else\n        return (sum(sol_DiffEq.u[end]), eltype(eltype(sol_DiffEq_doubleFloat.u)),\n                sum(sol_euler_vecTstep.u[end]), sum(sol_euler_fixTstep.u[end]),\n                eltype(eltype(sol_euler_doubleFloat.u)))\n    end\nend\n\nusing Test\n\nfunction runtests()\n    testval_diffEq = 3.7210048739504296\n    testval_diffEq_banded = 3.702806314278916\n\n    testval_euler = 3.721004873950427\n    testval_euler_banded = 3.7210048106612303\n\n    if VERSION >= VersionNumber(1, 9, 0)\n        approx_diffEq, approx_diffEq_banded, sol_diffEq_doubleFloat, approx_euler_vec, approx_euler, approx_euler_banded, sol_euler_doubleFloat = main()\n\n        all_tests = approx_diffEq ≈ testval_diffEq &&\n                    sol_diffEq_doubleFloat == Double64 == sol_euler_doubleFloat &&\n                    approx_diffEq_banded ≈ testval_diffEq_banded &&\n                    approx_euler ≈ testval_euler ≈ approx_euler_vec &&\n                    approx_euler_banded ≈ testval_euler_banded\n    else\n        approx_diffEq, sol_diffEq_doubleFloat, approx_euler_vec, approx_euler, sol_euler_doubleFloat = main()\n\n        all_tests = approx_diffEq ≈ testval_diffEq &&\n                    sol_diffEq_doubleFloat == Double64 == sol_euler_doubleFloat &&\n                    approx_euler ≈ testval_euler ≈ approx_euler_vec\n    end\n\n    @test all_tests\nend\n\nend","category":"page"},{"location":"module_examples/Example101_LinearDiffusion/","page":"101:  Linear Diffusion","title":"101:  Linear Diffusion","text":"","category":"page"},{"location":"module_examples/Example101_LinearDiffusion/","page":"101:  Linear Diffusion","title":"101:  Linear Diffusion","text":"This page was generated using Literate.jl.","category":"page"}]
}
