<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solvers · SkeelBerzins.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SkeelBerzins.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../problem_definition/">Problem Definition</a></li><li class="is-active"><a class="tocitem" href>Solvers</a><ul class="internal"><li><a class="tocitem" href="#Define-the-PDE"><span>Define the PDE</span></a></li><li><a class="tocitem" href="#Define-the-initial-conditions"><span>Define the initial conditions</span></a></li><li><a class="tocitem" href="#Define-the-boundary-conditions"><span>Define the boundary conditions</span></a></li><li><a class="tocitem" href="#Obtaining-Solutions"><span>Obtaining Solutions</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li></ul></li><li><a class="tocitem" href="../performance/">Achieve performance</a></li><li><a class="tocitem" href="../public_private_APIs/">Public and Private APIs</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../example101/">101: Linear Diffusion equation (DiffEq)</a></li><li><a class="tocitem" href="../example102/">102: Linear Diffusion equation</a></li><li><a class="tocitem" href="../example103/">103: Nonlinear Diffusion equation (DiffEq)</a></li><li><a class="tocitem" href="../example104/">104: Nonlinear Diffusion equation</a></li><li><a class="tocitem" href="../example105/">105: Linear Diffusion equation in cylindrical coordinates (DiffEq)</a></li><li><a class="tocitem" href="../example106/">106: Linear Diffusion equation cylindrical coordinates</a></li><li><a class="tocitem" href="../example107/">107: Poisson equation</a></li><li><a class="tocitem" href="../example108/">108: Stationary nonlinear diffusion equation</a></li><li><a class="tocitem" href="../example109/">109: System of Reaction-Diffusion equations (DiffEq)</a></li><li><a class="tocitem" href="../example110/">110: System of Reaction-Diffusion equations</a></li><li><a class="tocitem" href="../example111/">111: Linear Diffusion equation in spherical coordinates (DiffEq)</a></li><li><a class="tocitem" href="../example112/">112: Linear Diffusion equation in spherical coordinates</a></li><li><a class="tocitem" href="../example201/">201: Interpolation of Partial Derivatives</a></li><li><a class="tocitem" href="../example301/">301: PDE Constrained Optimization</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gregoirepourtier/SkeelBerzins.jl/blob/main/docs/src/solvers.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Solvers"><a class="docs-heading-anchor" href="#Solvers">Solvers</a><a id="Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers" title="Permalink"></a></h1><p>Now that we have an understanding of the overall problem definition, we can look into the various solvers included in the package and investigate their specific input and output parameters in detail.</p><p>The solvers expect the PDE problem to be described in the following way.</p><h2 id="Define-the-PDE"><a class="docs-heading-anchor" href="#Define-the-PDE">Define the PDE</a><a id="Define-the-PDE-1"></a><a class="docs-heading-anchor-permalink" href="#Define-the-PDE" title="Permalink"></a></h2><p>In order to define the PDE(s), we have to follow the format introduced in the previous section on <a href="https://gregoirepourtier.github.io/SkeelBerzins.jl/dev/problem_definition/#Problem-Definition">Problem definition</a>. For the purpose of this explanation, we use the function <code>pdefunction(x,t,u,dudx)</code> to describe the PDE(s). The inputs of the function are self-explanatory. It will then returns the capacity <code>c(x,t,u,dudx)</code>, the flux <code>f(x,t,u,dudx)</code> and the source <code>s(x,t,u,dux)</code> terms.</p><p>This function will be passed as an argument to the solver.</p><h2 id="Define-the-initial-conditions"><a class="docs-heading-anchor" href="#Define-the-initial-conditions">Define the initial conditions</a><a id="Define-the-initial-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Define-the-initial-conditions" title="Permalink"></a></h2><p>To define the initial condition(s), we introduce the function <code>icfunction(x)</code>. For problems that contain at least one parabolic equation, it will return the evaluation of the initial condition on the spatial mesh <code>xmesh</code> at the initial time <span>$t_0$</span>.<br/>For stationary problems it will return the evaluation of the initial value on the spatial mesh <code>xmesh</code> used for the newton solver.</p><p>This function will be passed as an argument to the solver.</p><h2 id="Define-the-boundary-conditions"><a class="docs-heading-anchor" href="#Define-the-boundary-conditions">Define the boundary conditions</a><a id="Define-the-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Define-the-boundary-conditions" title="Permalink"></a></h2><p>To represent the boundary condition, we introduce the function <code>bdfunction(xl,ul,xr,ur,t)</code>. The input arguments are:</p><ul><li><code>xl</code>: left boundary point of the problem.</li><li><code>ul</code>: estimate of the solution evaluated at the left boundary of the domain.</li><li><code>xr</code>: right boundary point of the problem.</li><li><code>ur</code>: estimate of the solution evaluated at the right boundary of the domain.</li><li><code>t</code>: evaluates the boundary conditions at time <span>$t \in [t_0,t_{end}]$</span>.</li></ul><p>The function will return the terms of the boundary conditions introduced in the problem defintion section, i.e. <code>p(x,t,u)</code> and <code>q(x,t)</code> for the left and right part of the spatial mesh.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If <span>$m&gt;0$</span> and the left boundary point of the domain <span>$a=0$</span>, the solver ignores the given boundary condition to enforce the symmetry condition    resulting in a more accurate solution near x=0.</p></div></div><p>This function will be passed as an argument to the solver.</p><h2 id="Obtaining-Solutions"><a class="docs-heading-anchor" href="#Obtaining-Solutions">Obtaining Solutions</a><a id="Obtaining-Solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Obtaining-Solutions" title="Permalink"></a></h2><p>Having defined the PDE formulation, the solver function <code>pdepe</code> can now be introduced. Look <a href="../public_private_APIs/#SkeelBerzins.pdepe"><code>pdepe</code></a>.</p><h3 id="Internal-method:-implicit-Euler-method"><a class="docs-heading-anchor" href="#Internal-method:-implicit-Euler-method">Internal method: implicit Euler method</a><a id="Internal-method:-implicit-Euler-method-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-method:-implicit-Euler-method" title="Permalink"></a></h3><h4 id="Parabolic-equation(s)"><a class="docs-heading-anchor" href="#Parabolic-equation(s)">Parabolic equation(s)</a><a id="Parabolic-equation(s)-1"></a><a class="docs-heading-anchor-permalink" href="#Parabolic-equation(s)" title="Permalink"></a></h4><p>The package contains an implementation of the implicit Euler method which can be used to solve parabolic equation(s). The method has a first order error with respect to time.</p><h4 id="Elliptic-Equations"><a class="docs-heading-anchor" href="#Elliptic-Equations">Elliptic Equations</a><a id="Elliptic-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Elliptic-Equations" title="Permalink"></a></h4><p>Only the internal method can be used to solve stationary problems and it is written in the following manner:</p><p class="math-container">\[M \frac{u^{k+1}-u^k}{\Delta t} = A(u^{k+1})\]</p><p>with <span>$M$</span> the mass matrix, <span>$\Delta t$</span> the time step used for the time discretization, <span>$A$</span> the (non)linear operator resulting from the space discretization, <span>$u^k$</span> and <span>$u^{k+1}$</span> the estimate solutions at time <span>$t_0 + k \Delta t$</span> and <span>$t_0 + (k+1) \Delta t$</span> respectively.</p><p>In Julia, positive infinity is defined as <code>Inf</code>. By setting <span>$\Delta t =$</span> Inf, it follows that <span>$\frac{1}{\Delta t} = 0$</span> and thus we are left with the stationary problem which can solved by using the Newton solver (see <a href="../public_private_APIs/#SkeelBerzins.newton"><code>SkeelBerzins.newton</code></a>).</p><p>It results that the solution for the stationary problem can be obtained by running one iteration of the implicit Euler method.</p><h3 id="Solve-with-DifferentialEquations.jl"><a class="docs-heading-anchor" href="#Solve-with-DifferentialEquations.jl">Solve with DifferentialEquations.jl</a><a id="Solve-with-DifferentialEquations.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-with-DifferentialEquations.jl" title="Permalink"></a></h3><p><a href="https://gregoirepourtier.github.io/SkeelBerzins.jl/dev/">SkeelBerzins.jl</a> is also compatible with the <a href="https://docs.sciml.ai/DiffEqDocs/stable/">DifferentialEquations.jl</a> package.</p><p>It is possible to return the data from the problem in a <a href="../public_private_APIs/#SkeelBerzins.ProblemDefinition"><code>SkeelBerzins.ProblemDefinition</code></a> structure, then to define an ODEFunction, an ODEProblem and solve it using any ODE/DAE solvers from DifferentialEquations.jl.</p><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><h3 id="Solve-linear-diffusion-problem-in-cartesian-coordinates-with-homogeneous-Neumann-boundary-conditions-using-internal-implicit-Euler-method"><a class="docs-heading-anchor" href="#Solve-linear-diffusion-problem-in-cartesian-coordinates-with-homogeneous-Neumann-boundary-conditions-using-internal-implicit-Euler-method">Solve linear diffusion problem in cartesian coordinates with homogeneous Neumann boundary conditions using internal implicit Euler method</a><a id="Solve-linear-diffusion-problem-in-cartesian-coordinates-with-homogeneous-Neumann-boundary-conditions-using-internal-implicit-Euler-method-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-linear-diffusion-problem-in-cartesian-coordinates-with-homogeneous-Neumann-boundary-conditions-using-internal-implicit-Euler-method" title="Permalink"></a></h3><pre><code class="nohighlight hljs">using SkeelBerzins

# Define symmetry of the problem
m = 0

# Define PDE Formulation
function pdefunction(x,t,u,dudx)
    c = 1
    f = dudx
    s = 0

    c,f,s
end

# Define the initial condition
icfunction(x) = exp(-100*(x-0.25)^2)

# Define the boundary condtions
function bdfunction(xl,ul,xr,ur,t)
    pl = 0
    ql = 1
    pr = 0
    qr = 1

    pl,ql,pr,qr
end

# Define the spatial discretization
xmesh = collect(range(0,1,length=21))

# Define the time interval
tspan = (0,1)

# Solve
sol = pdepe(m,pdefunction,icfunction,bdfunction,xmesh,tspan)</code></pre><h3 id="Solve-linear-diffusion-problem-in-cartesian-coordinates-with-homogeneous-Neumann-boundary-conditions-using-the-DifferentialEquations.jl"><a class="docs-heading-anchor" href="#Solve-linear-diffusion-problem-in-cartesian-coordinates-with-homogeneous-Neumann-boundary-conditions-using-the-DifferentialEquations.jl">Solve linear diffusion problem in cartesian coordinates with homogeneous Neumann boundary conditions using the DifferentialEquations.jl</a><a id="Solve-linear-diffusion-problem-in-cartesian-coordinates-with-homogeneous-Neumann-boundary-conditions-using-the-DifferentialEquations.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-linear-diffusion-problem-in-cartesian-coordinates-with-homogeneous-Neumann-boundary-conditions-using-the-DifferentialEquations.jl" title="Permalink"></a></h3><pre><code class="nohighlight hljs">using SkeelBerzins

# Define symmetry of the problem
m = 0

# Define PDE Formulation
function pdefunction(x,t,u,dudx)
    c = 1
    f = dudx
    s = 0

    c,f,s
end

# Define the initial condition
icfunction(x) = exp(-100*(x-0.25)^2)

# Define the boundary condtions
function bdfunction(xl,ul,xr,ur,t)
    pl = 0
    ql = 1
    pr = 0
    qr = 1

    pl,ql,pr,qr
end

# Define the spatial discretization
xmesh = collect(range(0,1,length=21))

# Define the time interval
tspan = (0,1)

# Define Keyword Arguments
params = SkeelBerzins.Params()
params.solver = :DiffEq

# Solve
problem_data = pdepe(m,pdefunction,icfunction,bdfunction,xmesh,tspan ; params=params)
problem_ode = DifferentialEquations.ODEProblem(problem_data)
sol_ode = DifferentialEquations.solve(problem,Rosenbrock23())
sol = reshape(sol_ode,problem_data)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../problem_definition/">« Problem Definition</a><a class="docs-footer-nextpage" href="../performance/">Achieve performance »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 23 March 2023 08:25">Thursday 23 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
