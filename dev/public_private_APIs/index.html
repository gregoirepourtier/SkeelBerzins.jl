<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public and Private APIs · SkeelBerzins.jl</title><meta name="title" content="Public and Private APIs · SkeelBerzins.jl"/><meta property="og:title" content="Public and Private APIs · SkeelBerzins.jl"/><meta property="twitter:title" content="Public and Private APIs · SkeelBerzins.jl"/><meta name="description" content="Documentation for SkeelBerzins.jl."/><meta property="og:description" content="Documentation for SkeelBerzins.jl."/><meta property="twitter:description" content="Documentation for SkeelBerzins.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SkeelBerzins.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../problem_definition/">Problem Definition</a></li><li><a class="tocitem" href="../solvers/">Solvers</a></li><li><a class="tocitem" href="../performance/">Achieve performance</a></li><li class="is-active"><a class="tocitem" href>Public and Private APIs</a><ul class="internal"><li><a class="tocitem" href="#Public-API"><span>Public API</span></a></li><li><a class="tocitem" href="#Private-API"><span>Private API</span></a></li></ul></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/example101/">101: Linear Diffusion equation</a></li><li><a class="tocitem" href="../examples/example102/">102: Nonlinear Diffusion equation</a></li><li><a class="tocitem" href="../examples/example103/">103: Linear Diffusion equation in cylindrical coordinates</a></li><li><a class="tocitem" href="../examples/example104/">104: Poisson equation</a></li><li><a class="tocitem" href="../examples/example105/">105: Stationary nonlinear diffusion equation</a></li><li><a class="tocitem" href="../examples/example106/">106: System of Reaction-Diffusion equations</a></li><li><a class="tocitem" href="../examples/example107/">107: Linear Diffusion equation in spherical coordinates</a></li><li><a class="tocitem" href="../examples/example201/">201: Interpolation of Partial Derivatives</a></li><li><a class="tocitem" href="../examples/example301/">301: PDE Constrained Optimization</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Public and Private APIs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public and Private APIs</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gregoirepourtier/SkeelBerzins.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gregoirepourtier/SkeelBerzins.jl/blob/main/docs/src/public_private_APIs.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-and-private-APIs"><a class="docs-heading-anchor" href="#Public-and-private-APIs">Public and private APIs</a><a id="Public-and-private-APIs-1"></a><a class="docs-heading-anchor-permalink" href="#Public-and-private-APIs" title="Permalink"></a></h1><p>We present here an index of all the methods that are present in the package. These are separated into two classes:</p><ol><li>Public API</li><li>Private API</li></ol><h2 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h2><h3 id="Solvers"><a class="docs-heading-anchor" href="#Solvers">Solvers</a><a id="Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SkeelBerzins.pdepe" href="#SkeelBerzins.pdepe"><code>SkeelBerzins.pdepe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pdepe(m, pdefunction, icfunction, bdfunction, xmesh, tspan ; params=SkeelBerzins.Params(), kwargs...)</code></pre><p>Solve 1D elliptic and parabolic partial differential equation(s) using the spatial discretization  method described in [1]. Note that to use this method, one of the PDEs must be parabolic. The time discretization is either done by the implicit Euler method (internal method) or by using a  ODE/DAE solver from the <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a>  package. For more information on how to define the different inputs to solve a problem, look at the  following sections: <a href="https://gregoirepourtier.github.io/SkeelBerzins.jl/dev/problem_definition/">Problem Definition</a>  and <a href="https://gregoirepourtier.github.io/SkeelBerzins.jl/dev/solvers/">Solvers</a>.</p><p>Input arguments:</p><ul><li><code>m</code>: scalar referring to the symmetry of the problem. It can either take the value <code>m=0</code>, <code>m=1</code> or       <code>m=2</code> representing cartesian, cylindrical or spherical coordinates respectively.</li><li><code>pdefunction</code>: Function. Defines the formulation of the PDE(s) using capacity, flux and source                 terms.</li><li><code>icfunction</code>: Function. Defines the initial condition(s) of the problem to solve (if                <code>tstep!=Inf</code> - initial condition(s) from the ODE/DAE problem, else if                <code>tstep=Inf</code> - initial value(s) used for the newton solver).</li><li><code>bdfunction</code>: Function. Defines the boundary conditions of the problem.</li><li><code>xmesh</code>: 1D array representing the spatial mesh on which the user intends to obtain the solution.</li><li><code>tspan</code>: tuple <span>$(t_0, t_{end})$</span> representing the time interval of the problem.</li></ul><p>Keyword argument:</p><ul><li><code>params</code>: defines a <a href="#SkeelBerzins.Params"><code>SkeelBerzins.Params</code></a> struct containing the keyword arguments from the            solvers.</li><li><code>kwargs</code>: instead of using the <a href="#SkeelBerzins.Params"><code>SkeelBerzins.Params</code></a> struct, the user can pass directly            fields from this particular struct to the solver.</li></ul><p>Returns a <a href="https://docs.sciml.ai/RecursiveArrayTools/stable/array_types/#RecursiveArrayTools.DiffEqArray"><code>RecursiveArrayTools.DiffEqArray</code></a>  or a <a href="#SkeelBerzins.ProblemDefinition"><code>SkeelBerzins.ProblemDefinition</code></a> struct, depending on the selected solver (either :euler or :DiffEq).  The obtained solution includes a linear interpolation method in time and can be used to evaluate the  solution at any time step within the interval <span>$(t_0,t_{end})$</span> (accessible using <code>sol(t)</code>).  A spatial interpolation similar as the <a href="#SkeelBerzins.pdeval"><code>pdeval</code></a> function is available on the solution object  using the command <code>sol(x_eval,t,pb)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gregoirepourtier/SkeelBerzins.jl/blob/6b125db5bb4666463b918605c7bfe2e24e971110/src/pdepe.jl#L5-L40">source</a></section><section><div><pre><code class="language-julia hljs">pdepe(m, pdefunction, icfunction, bdfunction, xmesh ; params=SkeelBerzins.Params(tstep=Inf), kwargs...)</code></pre><p>Solve 1D elliptic PDE(s) using the spatial discretization method described in [1] - <a href="#SkeelBerzins.pdepe"><code>pdepe</code></a>  variant to solve stationary problems. Performs one step of the implicit Euler method.</p><p>Input arguments:</p><ul><li><code>m</code>: scalar referring to the symmetry of the problem. It can either take the value <code>m=0</code>, <code>m=1</code> or      <code>m=2</code> representing cartesian, cylindrical or spherical coordinates respectively.</li><li><code>pdefunction</code>: Function. Defines the formulation of the PDE(s) using capacity, flux and source                 terms (capacity term should be set to 0).</li><li><code>icfunction</code>: Function. It defines the initial value(s) used for the Newton solver.</li><li><code>bdfunction</code>: Function. Defines the boundary conditions of the problem.</li><li><code>xmesh</code>: 1D array representing the spatial mesh on which the user intends to obtain the solution.</li></ul><p>Keyword argument:</p><ul><li><code>params</code>: defines a <a href="#SkeelBerzins.Params"><code>SkeelBerzins.Params</code></a> structure containing the keyword arguments from            the solvers.</li><li><code>kwargs</code>: instead of using the <a href="#SkeelBerzins.Params"><code>SkeelBerzins.Params</code></a> struct, the user can pass directly            fields from this particular struct to the solver.</li></ul><p>Returns a 1D Array with the solution available at the points defined by the spatial discretization  <code>xmesh</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gregoirepourtier/SkeelBerzins.jl/blob/6b125db5bb4666463b918605c7bfe2e24e971110/src/pdepe.jl#L145-L168">source</a></section></article><h3 id="Parameters-for-the-package"><a class="docs-heading-anchor" href="#Parameters-for-the-package">Parameters for the package</a><a id="Parameters-for-the-package-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters-for-the-package" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SkeelBerzins.Params" href="#SkeelBerzins.Params"><code>SkeelBerzins.Params</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Params</code></pre><p>Structure containing all the keyword arguments for the solver <a href="#SkeelBerzins.pdepe"><code>pdepe</code></a>.</p><ul><li><code>solver::Symbol</code>: Choice of the time discretization either use <code>:euler</code> for internal implicit Euler method or <code>:DiffEq</code> for the <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a> package.</li></ul><ul><li><code>tstep::Union{Float64, Vector{Float64}}</code>: Defines a time step (either pass a <code>Float64</code> or a <code>Vector</code>) when using the implicit Euler method. When set to <code>tstep=Inf</code>, it solves the stationary version of the problem.</li></ul><ul><li><code>hist::Bool</code>: Flag, returns with the solution, a list of 1d-array with the history from the newton solver.</li></ul><ul><li><code>sparsity::Symbol</code>: Choice of the type of matrix (<code>:sparseArrays</code>, <code>:banded</code>) use to store the jacobian.</li></ul><ul><li><code>linsolve::Union{Nothing, LinearSolve.SciMLLinearSolveAlgorithm}</code>: Choice of the solver for the LSE in the newton method, see <a href="https://docs.sciml.ai/LinearSolve/stable/solvers/solvers/"><code>LinearSolve.jl</code></a>.</li></ul><ul><li><code>maxit::Int64</code>: Maximum number of iterations for the Newton solver.</li></ul><ul><li><code>tol::Float64</code>: Tolerance used for Newton method. Returns solution if <span>$||\; u_{i+1} - u_{i} \;||_2 &lt;$</span> <code>tol</code>.</li></ul><ul><li><code>data::Bool</code>: Returns the data of the PDE problem</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gregoirepourtier/SkeelBerzins.jl/blob/6b125db5bb4666463b918605c7bfe2e24e971110/src/utils.jl#L179">source</a></section></article><h3 id="Compatibility-with-DifferentialEquations.jl"><a class="docs-heading-anchor" href="#Compatibility-with-DifferentialEquations.jl">Compatibility with DifferentialEquations.jl</a><a id="Compatibility-with-DifferentialEquations.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Compatibility-with-DifferentialEquations.jl" title="Permalink"></a></h3><p>Methods implemented in the SkeelBerzinsDiffEq.jl package extension.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.ODEProblem" href="#SciMLBase.ODEProblem"><code>SciMLBase.ODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ODEProblem(problem)</code></pre><p>Generate an <a href="https://docs.sciml.ai/DiffEqDocs/stable/types/ode_types/#SciMLBase.ODEProblem">ODEProblem</a> from the <a href="#SciMLBase.ODEFunction"><code>ODEFunction</code></a> which then can be solved by using the  <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/common_solver_opts/">solve</a> method.</p><p>Input arguments:</p><ul><li><code>problem</code>: Structure of type <a href="#SkeelBerzins.ProblemDefinition"><code>SkeelBerzins.ProblemDefinition</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gregoirepourtier/SkeelBerzins.jl/blob/6b125db5bb4666463b918605c7bfe2e24e971110/ext/SkeelBerzinsDiffEq.jl#L36-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reshape" href="#Base.reshape"><code>Base.reshape</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reshape(sol_ODE, problem)</code></pre><p>Reshape the solution <code>sol_ODE</code> obtained by the DifferentialEquations.jl package to obtain the solution at time t as a 2D-Array of size (npde,Nx). </p><p>Indeed since in the spatial discretization, we flattened the problem, the solution has a similar size.  So by reshaping the solution, we get a solution organised by unknows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gregoirepourtier/SkeelBerzins.jl/blob/6b125db5bb4666463b918605c7bfe2e24e971110/ext/SkeelBerzinsDiffEq.jl#L52-L60">source</a></section></article><h3 id="Interpolation-of-the-obtained-solution"><a class="docs-heading-anchor" href="#Interpolation-of-the-obtained-solution">Interpolation of the obtained solution</a><a id="Interpolation-of-the-obtained-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation-of-the-obtained-solution" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SkeelBerzins.pdeval" href="#SkeelBerzins.pdeval"><code>SkeelBerzins.pdeval</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pdeval(m, xmesh, u_approx, x_eval, pb)</code></pre><p>Function that interpolates with respect to the space component the solution obtained by the solver function <a href="#SkeelBerzins.pdepe"><code>pdepe</code></a>.</p><p>Input arguments:</p><ul><li><code>m</code>: symmetry of the problem (m=0,1,2 for cartesian, cylindrical or spherical).</li><li><code>xmesh</code>: space discretization.</li><li><code>u_approx</code>: approximate solution obtained by the solver <code>pdepe</code>.</li><li><code>x_eval</code>: point or vector of points where to interpolate the approximate solution.</li><li><code>pb</code>: structure defining the problem definition, see <a href="#SkeelBerzins.ProblemDefinition"><code>SkeelBerzins.ProblemDefinition</code></a>.</li></ul><p>Returns a tuple <span>$(u,dudx)$</span> corresponding to the solution and its partial derivative with respect to the space component evaluated in <code>x_eval</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gregoirepourtier/SkeelBerzins.jl/blob/6b125db5bb4666463b918605c7bfe2e24e971110/src/utils.jl#L377-L391">source</a></section></article><h2 id="Private-API"><a class="docs-heading-anchor" href="#Private-API">Private API</a><a id="Private-API-1"></a><a class="docs-heading-anchor-permalink" href="#Private-API" title="Permalink"></a></h2><p>These methods should only be considered for developers or people trying to understand the inner  workings of the package.</p><h3 id="Spatial-Discretization"><a class="docs-heading-anchor" href="#Spatial-Discretization">Spatial Discretization</a><a id="Spatial-Discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial-Discretization" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SkeelBerzins.assemble!" href="#SkeelBerzins.assemble!"><code>SkeelBerzins.assemble!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble!(du, u, problem, t)</code></pre><p>Performs space discretization following the difference equations described in [1].</p><p>Assemble the right-hand side <span>$f$</span> to generate an ODE/DAE problem:</p><p class="math-container">\[(M) \frac{du}{dt} = f(u,problem,t)\]</p><p>where the input <code>problem</code> is defined as a <a href="#SkeelBerzins.ProblemDefinition"><code>SkeelBerzins.ProblemDefinition</code></a> structure.</p><p>This function is specified in a way that it is compatible with the DifferentialEquations.jl package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gregoirepourtier/SkeelBerzins.jl/blob/6b125db5bb4666463b918605c7bfe2e24e971110/src/assembler.jl#L5-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SkeelBerzins.interpolation" href="#SkeelBerzins.interpolation"><code>SkeelBerzins.interpolation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interpolation(xl, ul, xr, ur, quadrature_point, problem)</code></pre><p>Interpolate u and <span>$\frac{du}{dx}$</span> between two discretization points at some specific quadrature point.</p><p>Input arguments:</p><ul><li><code>xl</code>: left boundary of the current interval.</li><li><code>ul</code>: solution evaluated at the left boundary of the current interval.</li><li><code>xr</code>: right boundary of the current interval.</li><li><code>ur</code>: solution evaluated at the right boundary of the current interval.</li><li><code>quadrature_point</code>: quadrature point chosen according to the method described in [1].</li><li><code>problem</code>: Structure of type <a href="#SkeelBerzins.ProblemDefinition"><code>SkeelBerzins.ProblemDefinition</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gregoirepourtier/SkeelBerzins.jl/blob/6b125db5bb4666463b918605c7bfe2e24e971110/src/utils.jl#L4-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SkeelBerzins.interpolation!" href="#SkeelBerzins.interpolation!"><code>SkeelBerzins.interpolation!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interpolation!(interp, d_interp, xl, ul, xr, ur, quadrature_point, problem)</code></pre><p>Mutating version of the <a href="#SkeelBerzins.interpolation"><code>interpolation</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gregoirepourtier/SkeelBerzins.jl/blob/6b125db5bb4666463b918605c7bfe2e24e971110/src/utils.jl#L52-L56">source</a></section></article><h3 id="Newton-solvers"><a class="docs-heading-anchor" href="#Newton-solvers">Newton solvers</a><a id="Newton-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Newton-solvers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SkeelBerzins.newton" href="#SkeelBerzins.newton"><code>SkeelBerzins.newton</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newton(b, tau, timeStep, problem, mass_matrix, cache, rhs ; tol=1.0e-10, maxit=100, hist_flag=false, linSol=nothing)</code></pre><p>Newton method solving nonlinear system of equations. The Jacobi matrix used for the iteration rule is computed with the help of the <a href="https://github.com/JuliaDiff/SparseDiffTools.jl"><code>SparseDiffTools.jl</code></a> package.</p><p>Input arguments:</p><ul><li><code>b</code>: right-hand side of the system to solve.</li><li><code>tau</code>: constant time step used for the time discretization.</li><li><code>timeStep</code>: current time step of tspan.</li><li><code>problem</code>: Structure of type <a href="#SkeelBerzins.ProblemDefinition"><code>SkeelBerzins.ProblemDefinition</code></a>.</li><li><code>mass_matrix</code>: mass matrix of the problem, see [<code>SkeelBerzins.mass_matrix</code>][@ref].</li><li><code>cache</code>: <code>SparseDiffTools.ForwardColorCache</code>. To avoid allocating the cache in each iteration of the newton solver when computing the jacobian.</li><li><code>rhs</code>: preallocated vector to avoid creating allocations.</li></ul><p>Keyword arguments:</p><ul><li><code>tol</code>: tolerance or stoppping criteria (by default to <code>1.0e-10</code>).</li><li><code>maxit</code>: maximum number of iterations (by default to <code>100</code>).</li><li><code>hist_flag</code>: flag to save the history and returns it (by default to <code>false</code>).</li><li><code>linSol</code>: choice of the solver for the LSE, see <a href="https://docs.sciml.ai/LinearSolve/stable/solvers/solvers/"><code>LinearSolve.jl</code></a> (by default <code>nothing</code>).</li></ul><p>Returns the solution of the nonlinear system of equations and if <code>hist_flag=true</code>, the history of the solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gregoirepourtier/SkeelBerzins.jl/blob/6b125db5bb4666463b918605c7bfe2e24e971110/src/utils.jl#L273-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SkeelBerzins.newton_stat" href="#SkeelBerzins.newton_stat"><code>SkeelBerzins.newton_stat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newton_stat(b, tau, timeStep, problem, cache, rhs ; tol=1.0e-10, maxit=100, hist_flag=false, linSol=nothing)</code></pre><p>Newton method solving nonlinear system of equations (variant of <a href="#SkeelBerzins.newton"><code>newton</code></a> for stationary problems).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gregoirepourtier/SkeelBerzins.jl/blob/6b125db5bb4666463b918605c7bfe2e24e971110/src/utils.jl#L334-L338">source</a></section></article><h3 id="Problem-definition"><a class="docs-heading-anchor" href="#Problem-definition">Problem definition</a><a id="Problem-definition-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-definition" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SkeelBerzins.ProblemDefinition" href="#SkeelBerzins.ProblemDefinition"><code>SkeelBerzins.ProblemDefinition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ProblemDefinition{T, Tv&lt;:(AbstractVector), Ti&lt;:Integer, Tm&lt;:Number, TMat&lt;:(AbstractMatrix), pdeFunction&lt;:Function, icFunction&lt;:Function, bdFunction&lt;:Function}</code></pre><p>Structure storing the problem definition.</p><ul><li><code>npde::Integer</code>: Number of unknowns</li></ul><ul><li><code>Nx::Integer</code>: Number of discretization points</li></ul><ul><li><code>xmesh::AbstractVector</code>: Grid of the problem</li></ul><ul><li><code>tspan::Tuple{Tm, Tm} where Tm&lt;:Number</code>: Time interval</li></ul><ul><li><code>singular::Bool</code>: Flag to know if the problem is singular or not</li></ul><ul><li><code>m::Integer</code>: Symmetry of the problem</li></ul><ul><li><code>jac::AbstractMatrix</code>: Jacobi matrix</li></ul><ul><li><code>inival::AbstractVector</code>: Evaluation of the initial condition</li></ul><ul><li><code>ξ::AbstractVector</code>: Interpolation points from the paper</li></ul><ul><li><p><code>ζ::AbstractVector</code></p></li><li><p><code>pdefunction::Function</code>: Function defining the coefficients of the PDE</p></li></ul><ul><li><code>icfunction::Function</code>: Function defining the initial condition</li></ul><ul><li><code>bdfunction::Function</code>: Function defining the boundary conditions</li></ul><ul><li><code>interpolant::AbstractVector</code>: Preallocated vectors for interpolation in assemble! function when solving system of PDEs</li></ul><ul><li><code>d_interpolant::AbstractVector</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gregoirepourtier/SkeelBerzins.jl/blob/6b125db5bb4666463b918605c7bfe2e24e971110/src/utils.jl#L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SkeelBerzins.problem_init" href="#SkeelBerzins.problem_init"><code>SkeelBerzins.problem_init</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">problem_init(m, xmesh, tspan, pdefun, icfun, bdfun, params)</code></pre><p>Function initializing the problem.</p><p>Input arguments: similar as <a href="#SkeelBerzins.pdepe"><code>pdepe</code></a>.</p><p>Returns the size of the space discretization Nx, the number of PDEs npde, the initial value inival,  some data types elTv and Ti, and the struct containing the problem definition pb.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gregoirepourtier/SkeelBerzins.jl/blob/6b125db5bb4666463b918605c7bfe2e24e971110/src/utils.jl#L596-L605">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SkeelBerzins.get_sparsity_pattern" href="#SkeelBerzins.get_sparsity_pattern"><code>SkeelBerzins.get_sparsity_pattern</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_sparsity_pattern(sparsity, Nx, npde, elTv)</code></pre><p>Function that provides the sparsity pattern in a SparseMatrixCSC.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gregoirepourtier/SkeelBerzins.jl/blob/6b125db5bb4666463b918605c7bfe2e24e971110/src/utils.jl#L717-L721">source</a></section><section><div><pre><code class="language-julia hljs">get_sparsity_pattern(sparsity, Nx, npde, elTv)</code></pre><p>Function that provides the sparsity pattern in a BandedMatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gregoirepourtier/SkeelBerzins.jl/blob/6b125db5bb4666463b918605c7bfe2e24e971110/src/utils.jl#L761-L765">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SkeelBerzins.get_quad_points_weights" href="#SkeelBerzins.get_quad_points_weights"><code>SkeelBerzins.get_quad_points_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_quad_points_weights(m, alpha, beta, gamma, singular)</code></pre><p>Calculate the quadrature points and weights for the one-point Gauss quadrature based on the  problem&#39;s specific symmetry, as described in the paper [1].</p><p>Input arguments:</p><ul><li><code>m</code>: scalar representing the symmetry of the problem.</li><li><code>alpha</code>: 1D array containing the left boundaries of the subintervals.</li><li><code>beta</code>: 1D array containing the right boundaries of the subintervals.</li><li><code>gamma</code>: 1D array containing the middle points of the subintervals.</li><li><code>singular</code>: boolean indicating whether the problem is singular or not.</li></ul><p>Returns the quadrature points <code>xi</code> and the weights <code>zeta</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gregoirepourtier/SkeelBerzins.jl/blob/6b125db5bb4666463b918605c7bfe2e24e971110/src/utils.jl#L666-L680">source</a></section></article><h3 id="Implicit-Euler-method"><a class="docs-heading-anchor" href="#Implicit-Euler-method">Implicit Euler method</a><a id="Implicit-Euler-method-1"></a><a class="docs-heading-anchor-permalink" href="#Implicit-Euler-method" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SkeelBerzins.implicitEuler!" href="#SkeelBerzins.implicitEuler!"><code>SkeelBerzins.implicitEuler!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">implicitEuler!(y,u,problem,tau,mass_matrix,timeStep)</code></pre><p>Assemble the system for the implicit Euler method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gregoirepourtier/SkeelBerzins.jl/blob/6b125db5bb4666463b918605c7bfe2e24e971110/src/utils.jl#L233-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SkeelBerzins.implicitEuler_stat!" href="#SkeelBerzins.implicitEuler_stat!"><code>SkeelBerzins.implicitEuler_stat!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">implicitEuler_stat!(y,u,problem,tau,timeStep)</code></pre><p>Assemble the system for the implicit Euler method (variant method for stationary problems).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gregoirepourtier/SkeelBerzins.jl/blob/6b125db5bb4666463b918605c7bfe2e24e971110/src/utils.jl#L253-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SkeelBerzins.mass_matrix" href="#SkeelBerzins.mass_matrix"><code>SkeelBerzins.mass_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mass_matrix(problem)</code></pre><p>Assemble the diagonal mass matrix M of the system of differential equations when solving a problem  with at least one parabolic PDE. The coefficients from M either take the value 0 or 1 since it is  scaled in the difference equations in the right-hand side.</p><p>The entries of the matrix are set to 0 when the corresponding equation of the system is elliptic or the boundary condition is pure Dirichlet leading to solve a Differential-Algebraic system of Equations. In the case where the mass matrix is identity, we solve a system of ODEs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gregoirepourtier/SkeelBerzins.jl/blob/6b125db5bb4666463b918605c7bfe2e24e971110/src/assembler.jl#L140-L150">source</a></section></article><h3 id="Post-processing"><a class="docs-heading-anchor" href="#Post-processing">Post-processing</a><a id="Post-processing-1"></a><a class="docs-heading-anchor-permalink" href="#Post-processing" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SkeelBerzins.interpolate_sol_time" href="#SkeelBerzins.interpolate_sol_time"><code>SkeelBerzins.interpolate_sol_time</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interpolate_sol_time(u_approx,t)</code></pre><p>Linear interpolatation of the solution with respect to the time component.</p><p>Input arguments:</p><ul><li><code>u_approx</code>: approximate solution obtained by the solver <code>pdepe</code>.</li><li><code>t</code>: time <span>$t \in [t_0,t_{end}]$</span>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gregoirepourtier/SkeelBerzins.jl/blob/6b125db5bb4666463b918605c7bfe2e24e971110/src/utils.jl#L562-L570">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SkeelBerzins.interpolate_sol_space" href="#SkeelBerzins.interpolate_sol_space"><code>SkeelBerzins.interpolate_sol_space</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interpolate_sol_space(u_approx, x_eval, pb, times ; val=true, deriv=true)</code></pre><p>Similar as <a href="#SkeelBerzins.pdeval"><code>pdeval</code></a>, i.e. interpolate the solution and its derivative with respect to the space component.</p><p>Input arguments:</p><ul><li><code>u_approx</code>: approximate solution obtained by the solver <code>pdepe</code>.</li><li><code>x_eval</code>: point or vector of points where to interpolate the approximate solution.</li><li><code>times</code>: point or vector of points which denotes the time step of the solution.</li><li><code>pb</code>: structure defining the problem definition, see <a href="#SkeelBerzins.ProblemDefinition"><code>SkeelBerzins.ProblemDefinition</code></a>.</li></ul><p>Keyword arguments:</p><ul><li><code>val</code>: flag to return the evaluation of the solution at the <code>x_eval</code> position.</li><li><code>deriv</code>: flag to return the derivative with respect to the space component  of the solution at the <code>x_eval</code> position.</li></ul><p>Returns a tuple <span>$(u,dudx)$</span> corresponding to the solution and its partial derivative with respect to the space component evaluated in <code>x_eval</code> at time <code>times</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gregoirepourtier/SkeelBerzins.jl/blob/6b125db5bb4666463b918605c7bfe2e24e971110/src/utils.jl#L438-L455">source</a></section></article><h3 id="Compatibility-with-DifferentialEquations.jl-2"><a class="docs-heading-anchor" href="#Compatibility-with-DifferentialEquations.jl-2">Compatibility with DifferentialEquations.jl</a><a class="docs-heading-anchor-permalink" href="#Compatibility-with-DifferentialEquations.jl-2" title="Permalink"></a></h3><p>The <code>ODEFunction</code> constructor is implicitely defined in the <code>ODEProblem</code> and so doesn&#39;t need to be  considered by the user to solve the problem with the <a href="https://docs.sciml.ai/DiffEqDocs/stable/">DifferentialEquations.jl</a>  package.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.ODEFunction" href="#SciMLBase.ODEFunction"><code>SciMLBase.ODEFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ODEFunction(problem)</code></pre><p>Generate an <a href="https://docs.sciml.ai/DiffEqDocs/stable/types/ode_types/#SciMLBase.ODEFunction">ODEFunction</a>  from the spatial discretization derived in the <a href="#SkeelBerzins.assemble!"><code>SkeelBerzins.assemble!</code></a> function.  It is expressed as a <a href="https://docs.sciml.ai/DiffEqDocs/stable/tutorials/dae_example/">mass matrix ODE</a>  if the mass matrix is different from the identity matrix or as a simple  <a href="https://docs.sciml.ai/DiffEqDocs/stable/tutorials/advanced_ode_example/#stiff">system of ODEs</a> otherwise  and defines the problem with respect to the sparsity pattern.</p><p>Input argument:</p><ul><li><code>problem</code>: Structure of type <a href="#SkeelBerzins.ProblemDefinition"><code>SkeelBerzins.ProblemDefinition</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gregoirepourtier/SkeelBerzins.jl/blob/6b125db5bb4666463b918605c7bfe2e24e971110/ext/SkeelBerzinsDiffEq.jl#L13-L25">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../performance/">« Achieve performance</a><a class="docs-footer-nextpage" href="../examples/example101/">101: Linear Diffusion equation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Friday 17 November 2023 15:41">Friday 17 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
